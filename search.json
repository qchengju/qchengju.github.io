[{"title":"伪类与伪元素","url":"/2025/08/30/css-%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0/","content":"伪类和伪元素一、核心区别：操作对象不同\n\n\n维度\n伪类（Pseudo-class）\n伪元素（Pseudo-element）\n\n\n\n操作对象\n对已有元素在特定状态或场景下的样式修饰\n创建不存在于 DOM 中的虚拟元素并设置样式\n\n\n本质\n元素的“状态&#x2F;场景”（如 hover、first-child）\n元素的“虚拟部分”（如首字母、前后内容）\n\n\n语法\n单冒号 :（如 :hover）\n双冒号 ::（CSS3 规范，兼容兼容旧浏览器兼容单冒号）\n\n\n数量限制\n一个元素可同时应用多个伪类（如 :hover:active）\n一个元素通常同时应用多个伪元素（仅能有一个）\n\n\n\n注意：  关于上表中的数量限制， button:hover:active:focus 是伪类可以这样设置叠加状态，而伪元素在同一时刻只需对一个虚拟部分设置样式。\n\n二、伪类（Pseudo-class）：修饰元素的特殊状态伪类用于选中处于特定状态或满足特定条件的元素，这些元素在 DOM 中真实存在，只是样式会根据状态变化。\n常见伪类及作用\n状态伪类：根据元素交互状态修饰\n\n:hover：鼠标悬停在元素上时\n:active：元素被点击（按下未松开）时\n:focus：元素获得焦点（如输入框被选中）时\n:visited：链接被访问后\n\n\n结构伪类：根据元素在 DOM 中的位置选中\n\n:first-child：父元素的第一个子元素\n:last-child：父元素的最后一个子元素\n:nth-child(n)：父元素的第 n 个子元素（n 可写公式，如 2n 表示偶数位）\n:only-child：父元素中唯一的子元素\n\n\n其他伪类：\n\n:empty：选中没有子元素的元素\n:checked：选中被勾选的表单元素（如单选框、复选框）\n:disabled：选中禁用状态的表单元素\n\n\n\n三、伪元素（Pseudo-element）：创建虚拟元素伪元素用于在元素的特定位置创建虚拟内容（这些内容不在 DOM 中），并为其设置样式。\n常见伪元素及作用\n::before：在元素内容前插入虚拟元素\n\n::after：在元素内容后插入虚拟元素\n\n必须配合 content 属性使用（即使值为空 &quot;&quot;），常用于添加装饰性内容（如图标、分隔线）。\n\n\n::first-letter：选中元素第一个字符（仅用于块级元素）\n\n::first-line：选中元素第一行文本（仅用于块级元素）\n\n::selection：选中用户鼠标选中的文本\n\n\n四、总结：关键区分点\n是否存在于 DOM：\n\n伪类修饰的是 DOM 中真实存在的元素（基于状态&#x2F;位置）。\n伪元素创建的是不存在于 DOM 的虚拟元素（如 ::before 是额外生成的）。\n\n\n用法场景：\n\n伪类：处理元素的交互状态（如 hover）或结构关系（如 first-child）。\n伪元素：处理元素的部分内容样式（如首字母）或添加装饰性内容（如 before&#x2F;after）。\n\n\n语法规范：\n\n伪类用单冒号 :（CSS3 兼容旧写法）。\n伪元素推荐用双冒号 ::（CSS3 新增，区别于伪类），但旧浏览器（如 IE8）仅支持单冒号。\n\n\n\n","categories":["css"],"tags":["css"]},{"title":"js中时间的处理","url":"/2024/09/07/js-js%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E5%A4%84%E7%90%86/","content":"介绍js 中对时间（Date）已经有了十分完备的方法，你完全可以根据这些原生的方法封装出一个你想要的时间的格式。\n转换方法1. 转化为时间戳\n时间戳:指的是自 1970 年 1 月 1 日 00:00:00 UTC 起至指定日期所经过的毫秒数。\n\n转换方法： getTime()  传入日期 &#x3D;&#x3D;&gt; 时间戳\nconst date = new Date();const timestamp = date.getTime();console.log(&#x27;时间戳:&#x27;, timestamp);\n2. 转化为本地时间字符串转化方法： localTimeString() Date &#x3D;&#x3D;&gt; 本地语言习惯的时间字符串\nconst date = new Date();const options = &#123;year: &#x27;numeric&#x27;,month: &#x27;long&#x27;,day: &#x27;numeric&#x27;,hour: &#x27;numeric&#x27;,minute: &#x27;numeric&#x27;,second: &#x27;numeric&#x27;,timeZoneName: &#x27;short&#x27; &#125;;const formattedTime = date.toLocaleString(&#x27;zh-CN&#x27;, options);console.log(&#x27;自定义格式本地时间字符串:&#x27;, formattedTime);\n3. 转换为 Date 对象转化方法： new Date(str)  将时间字符串传到 str 位置。\n内置方法\n**toDateString()**，把 Date 对象的日期部分转换为字符串。&#x2F;&#x2F;‘Sat May 06 2025’\n**toTimeString()**，把 Date 对象的时间部分转换为字符串。&#x2F;&#x2F;‘14:05:29 GMT+0800 (中国标准时间)’\n**toGMTString()**，获取格林尼治时间字符串。&#x2F;&#x2F;‘Sat, 06 May 2025 06:03:42 GMT’\n**toString()**，把 Date 对象转换为字符串。&#x2F;&#x2F;‘Sat May 06 2025 14:00:02 GMT+0800 (中国标准时间)’\n**toUTCString()**，根据世界时(UTC)，把 Date 对象转换为字符串。&#x2F;&#x2F;‘Sat, 06 May 2025 06:07:58 GMT’\n**toLocaleString()**，根据本地时间格式，把 Date 对象转换为字符串。&#x2F;&#x2F;‘2025&#x2F;5&#x2F;6 14:08:56’\n**toLocaleDateString()**，根据本地时间格式，把 Date 对象的日期部分转换为字符串。&#x2F;&#x2F;‘2025&#x2F;5&#x2F;6’\n**toLocaleTimeString()**，根据本地时间格式，把 Date 对象的时间部分转换为字符串。&#x2F;&#x2F;‘14:10:16’\n**toJSON()**，将 Date 对象转换为字符串，并格式化为 JSON 时间格式。&#x2F;&#x2F;‘2025-05-06T06:10:51.797Z’\n**toISOString()**，使用 ISO 标准返回 Date 对象的字符串格式。&#x2F;&#x2F;‘2025-05-06T06:12:01.451Z’\n\n","categories":["js"],"tags":["js"]},{"title":"picgo+github 配置个人图床","url":"/2025/09/09/picgo+github%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/","content":"使用场景（需求）前端使用 img 标签时可以直接将 src 换成网络路径直接展示，还有就是最常用的 md 中的图片插入，可以只需要在写的时候写上路径就能在任何地方展示。\n配置方法\n注册一个 github 账号，在设置中找到 token 选择 classic token\n将第一个作为仓库勾选上，生成\n记住你的 token 它只会出现这一次，以后你将无法访问到它。\n\npicgo 设置\n","categories":["环境&配置"],"tags":["环境&配置"]},{"title":"js的数组方法","url":"/2024/08/29/js-JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","content":"介绍JS 数组是极为灵活的数据结构，应用极为广泛，在这些封装好的方法帮助下，可以大大提高开发效率，和代码可读性。\n方法1. arr.push( )   该方法接收一个或多个参数并将所有的参数按顺序插入数组的末尾。   若将数组作为参数传入，不会将传入的数组拆开而是直接加入到原数组中。\n2. arr.forEach(callback )   该方法接收一个回调函数作为参数 ，\n//该方法没有返回值，直接在回调函数内对数组处理即可//其中回调函数的参数分别是遍历到的当前元素 当前元素的索引 被遍历的数组arr.forEach(function (item, index, thisarr) &#123;  //处理元素&#125;);\n\n3. arr.map(callback)   该方法同样接收一个回调函数作为参数，\n//该方法最后返回一个与原数组相同长度的新数组//在回调函数内部可以对原数组处理，其中参数与forEach的回调参数相同const newArr = arr.map(function (item, index, thisarr) &#123;  return result;&#125;);\n\n4. arr.fliter(callback)   该方法也接收一个回调函数为参\n//该方法最后返回一个与原数组相同长度的新数组//在回调函数内返回一个布尔类型的数据决定当前元素是否返回到新数组中//，其中参数与forEach的回调参数相同const newArr = arr.fliter(function (item, index, thisarr) &#123;  return flag;&#125;);\n\n5. arr.findIndex(callback)   该方法接收一个回调函数\n//该方法最后返回一个查找到元素的索引，找不到返回 -1//在回调函数内返回一个布尔类型的数据决定当前元素是否找到了元素//，其中参数与forEach的回调参数相同const newArr = arr.findIndex(function (item, index, thisarr) &#123;  return flag;&#125;);\n\n6. arr.splice(a,b,c )   该方法接收三个参数，第一个是修改的索引，第二个是将要删除的个数，第三个或更多的元素是在要修改位置插入的，这个方法会原地修改数组。\n7. arr.sort(callback)   该方法为所有数组元素进行了排序，按照升序或者降序排列。\n//回调函数的两个参数是数组相邻的两项//a-b&lt;0时升序排列arr.sort(function (a, b) &#123;  return a - b;&#125;);\n\n8. arr.reverse( )   该方法可以直接将数组的元素反转顺序。\n9. arr.shift( )   删除第一个元素并返回该元素。\n10. arr.pop( )删除末尾元素并返回删除的元素。\n\n11. arr.unshift( )在数组起始处添加元素并返回数组长度。\n\n12. arr.join( )可以将数组转化为字符串，并将该字符串返回，传入的字符参数会作为里连接符。\n参数为字符。\n\n13. arr.concat( )传入两个数组合成一个数组并反回新数组。\n\n14. arr.slice( )arr.slice(起始索引，结束索引)\n包含开始不包含结束。\n可以只写一个参数，截取从该元素开始以后的所有元素。\n还可以写负参数，代表截取到倒数第几个元素。\n\n15. arr.includes( )判断传入的元素是否在数组中。\n\n","categories":["js"],"tags":["js"]},{"title":"前端包管理器","url":"/2025/09/19/web%E5%B7%A5%E7%A8%8B%E5%8C%96-%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/","content":"包管理器对于前端开发而言，包管理是其中非常重要的一环。\nnpmnpm作为node包管理器，是nodejs官方的包管理工具。尽管它解决的代码共享的问题，在那个年代是极为特殊的思想，但是它依旧有很多的问题存在。而其他几个包管理工具，或多或少都解决了这些问题。安装慢、node_modules 过大、依赖库版本锁定不一致 等等的问题。\nyarnyarn的出现纯粹是为了解决npm的这些问题。在那个 npm install 慢、依赖版本时常出错的年代，Yarn 就像是完成了一次大的技术升级，把整个包管理的流程都做了优化。\n\nyarn.lock 文件：引入了自己的锁文件（区别于 npm 的 package-lock.json），更早解决了依赖版本不一致的问题\n更快的安装体验：Yarn 通过缓存机制和并行安装方式，大大提升了安装速度。装过一次的包，下次无需重新拉。\n离线安装：这是一个非常实用的特性，即使断网，你也可以依赖缓存离线安装项目，适合对网络依赖敏感的开发场景。\n原子化安装：安装失败会自动回滚，防止项目进入“半安装”状态。\n\npnpmpnpm 的初衷是解决占用磁盘空间过大问题。pnpm 通过一种“硬链接 + 内容寻址”的存储方式，将所有依赖包统一下载到全局缓存中（.pnpm-store），每个项目的 node_modules 并不真的“安装”包，而是使用软链接指向缓存中的真实文件，同一个包只会下载、存储一份，再多个项目共用。这样就带来了巨多好处，比如：下载速度飞快，空间占用大幅度下降，并且还可以完美兼容现有生态（保留 node_modules）。并且，针对 Monorepo 架构，pnpm 也提供了非常好的支持（应该可以说是支持最好的包管理器了）\ncnpmcnpm 是淘宝团队基于 npm 封装的包管理工具，cnpm 默认使用淘宝镜像，速度比 npm 快很多。但是在我看来，cnpm有许多的问题，我不建议大家使用。\n常用命令\n\n\n功能\nNPM 命令\nYarn 命令\nPNPM 命令\n\n\n\n安装依赖\nnpm install\nyarn install\npnpm install\n\n\n安装特定包\nnpm install\nyarn add\npnpm add\n\n\n移除包\nnpm uninstall\nyarn remove\npnpm remove\n\n\n更新包\nnpm update\nyarn upgrade\npnpm update\n\n\n初始化项目\nnpm init\nyarn init\npnpm init\n\n\n","categories":["web工程化"],"tags":["web工程化"]},{"title":"前端模块化规范","url":"/2025/09/16/web%E5%B7%A5%E7%A8%8B%E5%8C%96-%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/","content":"前端模块化规范什么是模块化?模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元.\n编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块，是将不同功能的函数封装起来，并提供使用接口，他们彼此之间互不影响，想要什么功能，就加载什么模块，可以实现按需加载。\n简单来说，模块化就是把系统分割成独立的功能块,提高代码的复用性。\n模块化开发的意义优点\n便于多人协作开发，每个部分开发不会干扰其它地方 ,降低了耦合性\n便于调试修改，因为模块独立，发现问题比较容易，修改一处，也不影响别处，利于前端性能优化.  \n利于代码复用，小块的代码可以更方便拿到别的项目中不加或者稍加修改使用，提高可维护性.\n便于功能的扩充，因为软件各个部分是独立的，不需要理解整个软件就可以添加功能,适合二次开发.\n解决了部分恼人的命名冲突以及烦琐的文件依赖.\n\n缺点1.系统分层，调用链会很长  2.模块间通信,模块间发送消息会很耗性能\n模块化的意义在于最大化的设计重用，以最少的模块、零部件，更快速的满足更多的个性化需求。\n模块化开发的一些规范1. CommonJS这个规范是node的规范,在此之后前端的模块化发展迅速.许多的主流前端框架都是都是由node基于搭建\n使用require导入内置的包或者导入自己写的文件,导入本地的包时记得用./表示文件路径,核心模块不需要\nCommonJS规范（运行时）1、每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。2、在模块中使用global 定义全局变量，不需要导出，在别的文件中可以访问到。3、每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。4、通过 require加载模块，读取并执行一个js文件，然后返回该模块的exports对象。5、所有代码都运行在模块作用域，不会污染全局作用域。6、模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。7、模块加载的顺序，按照其在代码中出现的顺序。\n2. ESM（编译时）在 ES Module 中用 export 用来导出模块，import 用来导入模块。CommonJS 模块同步加载并执行模块文件，ESM 模块提前加载并执行模块文件，ESM模块在预处理阶段分析模块依赖，在执行阶段执行模块，两个阶段都采用深度优先遍历.其实就是客户端的导出规范.\nCommonJS 输出的是一个值的拷贝；ES Modules 生成一个引用，等到真的需要用到时，再到模块里面去取值，模块里面的变量，绑定其所在的模块。以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\nnode中使用这种导入模式需要把后缀改为mjs\nESM导入规则 1.导入变量名\nimport greet from &#39;./greeting.js&#39;;\n 2.解构导出\nimport &#123; add, subtract &#125; from &#39;./math.js&#39;;\n 3.全部导出\nimport * as math from &#39;./math.js&#39;;\n3. AMD规范（requirejs）AMD的核心是预加载，先对依赖的全部文件进行加载，加载完了再进行处理。  适合在浏览器环境中异步加载模块。可以并行加载多个模块。 并可以按需加载。核心就是前端的require.js包的学习.\n使用    &lt;script data-main=&quot;js/main&quot; src=&quot;js/require.js&quot;&gt;&lt;/script&gt;    src引入requirejs，date-main将main模块为主模块加载\n官方网址: https://requirejs.org\n4. CMD规范（seajs）即通用模块定义。按需加载。在 CMD 规范中，一个模块就是一个文件，使用define来进行模块，define是一个全局函数。  factory 可以是一个函数，也可以是一个对象或字符串。\n唯一的问题：浏览器端不支持CommonJS规范淘宝“玉伯”仿照CommonJS规范，研发了一款插件 sea.js ，旨在把CommonJS规范搬到浏览器端运行「这种模块思想被称之为CMD」\n使用 (CMD)define(&#123;&#x27;website&#x27;:&#x27;oecom&#x27;&#125;);define(&#x27;这里是OECOM&#x27;);define(function(require,exports,module)&#123;&#125;)\n\nrequire参数也是一个方法，接收的参数为模块标识，其实就是需要加载模块的相对路径，作用就是加载其他模块。define(function(require,exports,module)&#123;    var a = require(&#x27;./a&#x27;);    //假设模块a有out方法。    a.out();&#125;)直接使用require加载属于是同步加载，require提供了async方法来在模块内部进行也不加载模块，并在加载完成以后执行指定的回调函数。define(function(require,exports,module)&#123;    require.async(&#x27;./a&#x27;,function(a)&#123;        a.doSomething()        &#125;)        require.async([&#x27;./c&#x27;,&#x27;./b&#x27;],function(c,b)&#123;        c.doSomething()        b.doSomething()        &#125;)    &#125;require 是同步往下执行，require.async 则是异步回调执行。require.async 一般用来加载可延迟异步加载的模块。exports是一个用来想外接提供模块接口的对象define(function(require,exports)&#123;    var name = 10;    exports.name = name;    exports.out = function()&#123;        console.log(&quot;输出内容&quot;)    &#125;    &#125;)    当然导出模块还可以直接使用return的方式define(function(require)&#123;    return&#123;        name:10,        out:function()&#123;            console.log(&quot;输出内容&quot;)        &#125;    &#125;&#125;)\n","categories":["web工程化"],"tags":["web工程化"]},{"title":"css BEM 规范","url":"/2025/08/15/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83-css%20BEM%20%E8%A7%84%E8%8C%83/","content":"CSS BEM 规范详解BEM（Block, Element, Modifier）是一种结构化的 CSS 命名方法，由 Yandex 团队提出，用于创建可复用、可维护的前端组件。核心思想是将 UI 拆分为独立的块，通过清晰的命名规则建立层级关系。\nBEM 核心概念1. Block（块）\n定义：页面中独立的、有意义的组件（如 header, card, menu）。\n命名：使用单个单词或连字符连接（如 user-card, search-form）。\n\n2. Element（元素）\n定义：块的组成部分，不能独立于块存在（如 navbar__link, card__title）。\n命名：使用双下划线 __ 连接块名和元素名（如 block__element）。\n\n3. Modifier（修饰符）\n定义：改变块或元素的外观、状态或行为（如 button--primary, card--disabled）。\n命名：使用双连字符 -- 连接（如 block--modifier 或 block__element--modifier）。\n\nBEM 命名规则\n使用连字符 - 分隔单词（如 user-card）。\n元素用双下划线 __ 连接块（如 user-card__avatar）。\n修饰符用双连字符 -- 连接（如 user-card--highlighted）。\n避免嵌套元素超过两层（如 block__elem1__elem2 不推荐）。\n\n","categories":["代码规范"],"tags":["代码规范"]},{"title":"原型和原型链问题探究","url":"/2024/08/29/js-%E5%8E%9F%E5%9E%8B%E9%97%AE%E9%A2%98/","content":"简介原型知识是前端必不可少的进阶知识之一，掌握好原型知识可以让前端开发中更加游刃有余。\nJS对象对象是一种引用或者说是复合的数据结构。展现形式是键值形式，关于对象有很多内容，本节不做深度探究这个问题。主要探究关于原型有关的问题。\n对象的创建模式1.字面量型  var obj1 = &#123;    name: &quot;Jack&quot;,     age: 26     &#125;2.Object构造函数模式var obj2 = new Object() obj2.name = &quot;Jack&quot; obj2.age = 263.构造函数模式function Test(name, age)&#123;    this.name = name    this.age = age    this.say = function()&#123;        console.log(&#x27;我能说话&#x27;)    &#125;&#125;var obj3 = new Test(&#x27;Jack&#x27;, 26)var obj4 = new Test(&#x27;Rose&#x27;, 25)\n\n原型问题主要是探究构造函数在上面那段代码中，Test 就是构造函数，obj3,obj4 是这个构造函数的实例对象，每个对象都有一个特殊的属性就是原型(prototype),(函数也有原型,函数也是对象）\n注意:1. 显式原型和隐式原型:\n    a. 显式原型用prototype属性表示和查找,这是函数的特有属性,普通对象没有.\n    b. 隐式原型用__proto__属性表示和查找,这是对象的属性,由于函数也是对象,\n    所以每个对象都有这个属性.\n    c. 隐式原型的值指向它构造函数的显式原型的值\n2. Object的原型对象的隐式原型指向null\n3. Function是在浏览器运行时已经创建好了的,是所有的起点.而且它的显式原型与隐式原型相等.\n4. 原型链指的就是隐式原型指向连起来的一条链状结构,在查找时会按照这条链,\n一直向上查找,直到null\n\n原型链\n拓展箭头函数出现的意义是什么?(这个问题不在于探究箭头函数的使用问题.)\n箭头函数是ES6中出现的一种简化写法,\n` say=()=&gt;&#123;&#125;`,箭头函数的出现关键是解决了JS中函数的二义性\n在其他面向对象的语言中在开始时就有类的概念,\n在js中函数不仅可以是指令序列,也可能是一个构造函数用来创建对象\n而箭头函数的出现限制了其只能是指令序列而不是构造函数.优化了代码执行\n\n","categories":["js"],"tags":["js"]},{"title":"git 工作流程介绍","url":"/2025/10/04/%E5%B7%A5%E5%85%B7-git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D/","content":"git介绍git 是什么？  git是一个先进的分布式版本控制系统。版本控制可以在编写代码时为你的文件生成快照，而这些快照保存的就是当时你文件的状态，如果发生了一些误删操作，就可以通过这个快照回溯到当时的那个状态。\nGit的工作流程图  \n","categories":["工具"],"tags":["工具"]},{"title":"git 基础命令","url":"/2025/08/05/%E5%B7%A5%E5%85%B7-git-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","content":"git 基础命令1. 配置不加尖括号内的东西可以查看相关配置。\n**git config [–global] user.name &lt;”your-name”&gt; :**设置名字\ngit config [–global] user.email &lt;”your-email”&gt; : 设置邮箱\n2. 启动\ngit init [project-name]: 创建或者（不加参数时）在当前目录初始化一个git代码库。\ngit clone url: 下载一个项目和它的整个代码历史。\n\n3. 日常操作\ngit init: 初始化仓库，默认 master .\n**git add .:**提交所有文件修改到缓存区\ngit add &lt;文件路径加文件全名&gt;：提交某些文件到缓存区\ngit status: 查看当前分支的状态\ngit diff: 展示文件在不同版本间的差异，不加参数时，会显示工作区和暂存区的文件差异。\ngit diff [–staged | –cached]: 显示添加到暂存区但是还未提交的修改内容。\ngit pull &lt;远程仓库名&gt; &lt;远程分支名&gt;: [&lt;本地分支名&gt;]: 拉取远程仓库的分支与本地当前分支合并[与传入参数的分支合并]。\ngit commit -m “&lt;注释&gt;”: 提交代码到本地仓库，并写上提交注释。（必须写注释否则提交失败）\ngit commit -v: 提交时显示所有diff信息\ngit rm –cached &lt;文件名&gt;:  删除缓存区文件 加上 -r 参数可以递归删除\n\n4. 分支操作\ngit branch: 查看本地所有分支\ngit branch -r: 查看远程所有分支\ngit branch -a: 查看本地和远程所有分支\ngit merge &lt;分支名&gt;: 合并分支\ngit merge –abort: 合并分支出现冲突时，取消合并，一切回到合并前的状态\ngit branch &lt;新分支名&gt;: 基于当前分支，新建一个分支\ngit checkout –orphan&lt;新分支名&gt;: 新建一个空分支(会保留之前分支的所有文件)\ngit branch-D&lt;分支名&gt;: 删除本地某个分支\ngit push&lt;远程库名&gt;:&lt;分支名&gt;: 删除远程某个分支\ngit branch &lt;新分支名称&gt; &lt;提交ID&gt;: 从提交历史恢复某个删掉的某个分支\ngit branch -m &lt;原分支名&gt;&lt;新分支名&gt;: 分支更名\ngit checkout &lt;分支名&gt;: 切换到本地某个分支\ngit checkout &lt;远程库名&gt;&#x2F;&lt;分支名&gt;: 切换到线上某个分支\ngit checkout -b &lt;新分支名&gt;: 把基于当前分支新建分支，并切换为这个分支\n\n5. 远程同步\ngit fetch［remote］: 下载远程仓库的所有变动\ngit remote-v: 显示所有远程仓库\ngit pull [remote] [branch]: 拉取远程仓库的分支与本地当前分支合并\ngit fetch: 获取线上最新版信息记录，不合并\ngit push [remote] [branch]: 上传本地指定分支到远程仓库\ngit push [remote］–force: 强行推送当前分支到远程仓库，即使有冲突\ngit push［remote］–all: 推送所有分支到远程仓库\n\n","categories":["工具"],"tags":["工具"]},{"title":"vim","url":"/2025/10/01/%E5%B7%A5%E5%85%B7-vim/","content":"vim介绍vim 是一个强大的文本编辑器，是 vi 的增强版，广泛用于 Linux 和UNIX 系统中，因为它不仅仅有文本编辑功能还可以进行复杂的文本操作。\n模式和切换vim 有三种主要模式：\n普通模式（Normal Mode）：你可以在这个模式下进行光标移动、删除、复制、粘贴等操作。\n插入模式（Insert Mode）：在这个模式下，你可以像普通文本编辑器一样输入内容。\n命令模式（Command Mode）：你可以在这个模式下输入命令来保存文件、退出等。\n\n模式切换：\n从 普通模式 切换到 插入模式：按 i（插入光标前）、I（行首插入）、a（光标后插入）、A（行尾插入）等。\n从 插入模式 切换回 普通模式：按 Esc 键。\n从 普通模式 切换到 命令模式：按 : 键。\n\nvim 启动# 打开文件：vim filename# 打开指定文件vim example.txt# 直接使用vim# 启动并打开一个空文件\nvim 中编辑\n进入插入模式\n\n在普通模式下，按下 i 进入插入模式。此时可以输入文本。\n常见的插入模式快捷键：\n\ni：光标前插入\nI：行首插入\na：光标后插入\nA：行尾插入\no：在当前行下方新建一行并插入\nO：在当前行上方新建一行并插入\n\n\n返回到普通模式\n\n在插入模式下，按 Esc 键返回到普通模式。\n常用操作\n移动光标  在普通模式下，光标移动是 Vim 的核心功能之一。你可以用以下键来精确控制光标：\nh：向左移动一个字符\nj：向下移动一行\nk：向上移动一行\nl：向右移动一个字符 更快速的移动：\nw：移动到下一个单词的开头\nb：移动到当前单词的开头\ne：移动到当前单词的结尾\n0：移动到当前行的行首\n$：移动到当前行的行尾\ngg：移动到文件的开头\nG：移动到文件的结尾\n\n\n复制、剪切和粘贴\nyy：复制当前行\n2yy：复制当前行及其下方的 1 行（2 行）\ndd：删除当前行\n2dd：删除当前行及其下方的 1 行（2 行）\np：在光标后粘贴（在行内粘贴）\nP：在光标前粘贴（在行首粘贴）\n\n\n保存和退出 # 保存文件:w# 退出 vim:q# 保存并退出:wq# 强制退出不保存:q!\n搜索和替换# 向前搜索：/ 然后输入搜索的关键字 按回车/keyword# n 查找下一个匹配项 N 查找上一个匹配项# 向后搜索：? 然后输入搜索关键字 按回车?keyword# 替换文件中的一个单词:%s/old/new/g# 将 old 全部替换为 new# %:表示整个文件# g:表示替换行中所有项（不加 g 只替换每行第一个匹配项）# 仅替换当前行：:s/old/new/g# 替换并确认每个替换：:%s/old/new/gc\n其他命令\n\n\n撤销操作：\nu：撤销上一个操作。\nCtrl + r：恢复撤销的操作。\n\n\n重做操作：\nCtrl + r：重做操作。\n\n\n查看文件信息：\n:set number：显示行号。\n:set nonumber：隐藏行号。\n\n\n跳转到特定行：\n:123：跳转到第 123 行。\n\n\n\n","categories":["工具"],"tags":["工具,linux"]},{"title":"git 提交和分支管理 规范","url":"/2025/10/04/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83-git%E6%8F%90%E4%BA%A4%E5%92%8C%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/","content":"git 提交和分支管理 规范git 提交规范 –&gt; Git Commit Message Conventions\n提交信息格式：&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\ntype 类型（必填）：描述提交的类别\n\nfeat：新功能（如 feat: add user login functionality）\n\nfix：修复 bug（如 fix: correct login timeout issue）\n\nrefactor：重构代码（不影响功能的改动）\n\ndocs：修改文档\n\nstyle：格式（代码样式修改，不影响代码逻辑）\n\ntest：增加测试\n\nchore：构建过程或辅助工具的变动\n\nscope: 本次提交影响的范围，标识变动涉及的模块或功能\n\nsubject： 提交说明（必填）：简洁说明本次变动，建议 50 字符以内\n\n\ngit分支管理规范\n功能分支命名应遵循 类型/功能 格式，常见类型包括：\n\nfeat/：新功能开发（如 feat/user-management）\nfix/：bug 修复（如 fix/login-bug）\nrefactor/：代码重构（如 refactor/auth-service）\nchore/：项目构建或工具变动（如 chore/update-dependencies）\ndocs/：文档修改（如 docs/update-readme）\nhotfix/：紧急修复（如 hotfix/critical-bug）\n\n\n功能分支应从 develop 分支创建，并在开发完成后合并回 develop 分支。围绕 develop 分支进行开发，以保持代码库的稳定性。\n\n当功能分支开发完成后，应删除该分支，以保持代码库的整洁。\n\n\n","categories":["代码规范"],"tags":["代码规范"]},{"title":"markdown语法","url":"/2025/08/20/%E7%8E%AF%E5%A2%83&%E9%85%8D%E7%BD%AE-markdown%20%E8%AF%AD%E6%B3%95/","content":"markdown语法标题语法根据# 号个数,每个# 号都代表一级标题.根据自己的层次结构决定使用几个#号。一般是有递进规律，一个井号的只用一次。\n换行语法在一行的末尾添加两个或者多个空格，\n然后回车可创建一个空行。\n强调语法粗体：请在单词或短语的前后各添加两个星号或下划线。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号。\n斜体：与粗体类似，可使用一个星号将想要斜体效果的部分引上。\n注意！！！： 可以使用三星号将想要特殊效果的部分引起来，代表斜体和粗体都加上了。\n引用语法\n用大于号代表引用,块引用就是将所有的行前都加上大于号\n\n嵌套引用也是支持的\n\n\n列表语法有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n\n\n\n\n\n无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n\n\n\n\n\n代码语法反引号： printf(&quot;hello world&quot;); 行代码\n围栏式代码块： 用三个反引号跟上代码语言，最后由三个反引号收尾。\npublic class Main &#123;    public static void main(String[] args) &#123;    System.out.println(&quot;hello world &quot;);    &#125;&#125;\n\n分割线语法\n要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。\n\n链接语法中括号加小括号语法 中括号内写名称（随便写） 小括号内写地址\n百度\n图片语法与链接语法类似但是要注意前面有个叹号。\n![图片](图片地址)\n表格语法用竖杠代表表格分割  |\n\n&gt;| 表头     | 表头 |&gt;|: -----------  :|: ----------- :| //在此可进行格式控制，加上：代表向左对齐或者向右对齐，都加时居中对齐, - 的数量与表格布局无关&gt;| Paragraph   | Text        |\n\n\n\n\n姓名\n班级\n年龄\n\n\n\n张三\n计科233\n18\n\n\n !!!注意 \n\n\n列表标题语法和需要在符号后加空格才会生效。\n所有格式控制符号一定是英文符号。\n有些找不到的键符可以在功能键下边那一行找，例如反引号在左上角。\n可以使用markdown编译器。 本地的 typora 或者是多端共享数据放在厂商服务器上的 语雀 ；自由选择编译器。可以在编译器上写好之后往博客上粘贴。\n我这里只是列举了简单的语法的基本使用，其他语法可以自行了解。\nmarkdown官网\n在word或者编译器中直接跳转链接需要使用ctrl键和鼠标点击。\n\n","categories":["学习笔记"],"tags":["学习笔记"]},{"title":"打包apk文件","url":"/2025/08/26/%E7%8E%AF%E5%A2%83&%E9%85%8D%E7%BD%AE-%E6%89%93%E5%8C%85apk%E6%96%87%E4%BB%B6/","content":"将 uniapp 项目打包成 安卓手机应用 apk环境准备打包安卓应用，首先需要的编辑器有 Android Studio，hbuilderx.hbuilderx是对 uniapp 应用具有极好的适配。\n云打包通过使用DCloud账号登录后，可以通过 hbx 直接云端打包，打包完成后可以根据提示路径下载apk文件。本文的重点是介绍，本地打包。\n本地打包\n使用 hbuilderx 打开项目，并选择 发行 -&gt; 本地打包 -&gt; 生成本地打包资源 。这一步通常是生成了一个 UNI*** 的文件夹。这个文件夹里就是本地的打包资源。\n打开 Android Studio ，新建项目，选择导入项目，选择 android&#x2F;app 文件夹。\n将证书文件复制到 android&#x2F;app 文件夹下。 android 证书通常是 .keystore 或者 .jks 文件。\n在这个目录下 找到 build.gradle 文件，配置证书路径密码。\n将android 文件夹导入到 android studio 中。\n点左侧的菜单栏选择 Build-&gt; Generate App Bundles or APKs  -&gt; Generate APKs\n\nothers！配置 appid 在 android&#x2F;app&#x2F;assets&#x2F;data&#x2F;dcloud_control.xml  文件中 UNI*** 格式的appid 配置。\n！需要在dcloud 账号中申请appid,注册并且完成认证，和创建项目。才能完成云打包。\n！获取安卓证书：获取安卓证书\n","categories":["环境&配置"],"tags":["环境&配置"]},{"title":"nginx","url":"/2025/09/24/%E8%BF%90%E7%BB%B4-nginx/","content":"nginx介绍nginx（发音同“engine x”）是一个高性能的 HTTP 和反向代理服务器，同时也支持邮件代理。它主要是为了解决高并发问题而出现的。\n安装方式主流的安装方式有三种：\n\n源码安装\n对应的软件包安装\nDocker 镜像安装\n\n在服务器环境上，docker安装确实最为推荐。不管是nginx还是其他的服务器，docker安装方式都相对简单，而且安装后，配置文件也相对简单。而且不用了直接删除容器。\nnginx 命令nginx -s reload  # 向主进程发送信号，重新加载配置文件，热重启nginx -s reopen  # 重启 Nginxnginx -s stop    # 快速关闭nginx -s quit    # 等待工作进程处理完成后关闭nginx -T         # 查看当前 Nginx 最终的配置，会在终端中打印出来nginx -t -c &lt;配置路径&gt;    # 检查配置文件的语法，默认路径不需要 -c 参数\nsystemctl start nginx    # 启动 Nginxsystemctl stop nginx     # 停止 Nginxsystemctl restart nginx  # 重启 Nginxsystemctl reload nginx   # 重新加载 Nginx，用于修改配置后systemctl enable nginx   # 设置开机启动 Nginxsystemctl disable nginx  # 关闭开机启动 Nginxsystemctl status nginx   # 查看 Nginx 运行状态\nnginx 配置文件文件位置：&#x2F;etc&#x2F;nginx&#x2F;nginx.conf 源码编译的：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf文件结构：    main # 全局配置，对全局生效    ├── events  # 配置影响 Nginx 服务器或与用户的网络连接    ├── http    # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置    │   ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分    │   ├── server   # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块    │   ├── server    │   │   ├── location  # server 块可以包含多个 location 块，location 指令用于匹配 uri    │   │   ├── location    │   │   └── …    │   └── …└── …\n反向代理、负载均衡反向代理：将用户请求转发给后端服务器，并返回结果给用户。对反向代理的理解首先要理解正向代理，正向代理在客户端一侧配置，客户端 → 正向代理 → 目标服务器，也就是正常的访问流程。反向代理是在服务端一侧配置，目标服务器 → 反向代理服务器 → 服务器集群。对客户端来说，反向代理是无感的。也就是说对服务端的代理（也可以说是对客户端来的请求进行了转发）这就是反向代理。\nserver &#123;  listen 9001;  server_name *.sherlocked93.club;  location ~ /edu/ &#123;    proxy_pass http://127.0.0.1:8080;  &#125;  location ~ /vod/ &#123;    proxy_pass http://127.0.0.1:8081;  &#125;&#125;\n\n负载均衡：将用户请求平均分配给多个后端服务器，从而提高服务器的负载。负载均衡的原理是把用户请求平均分配给多个后端服务器，从而提高服务器的负载。负载均衡的原理是把用户请求平均分配给多个后端服务器，从而提高服务器的负载。也是可以设置权重的为更高性能的服务器分配更多请求。\nhttp &#123;  upstream myserver &#123;    # ip_hash;  # ip_hash 方式    # fair;   # fair 方式    server 127.0.0.1:8081;  # 负载均衡目的服务地址    server 127.0.0.1:8080;    server 127.0.0.1:8082 weight=10;  # weight 方式，不写默认为 1 设置权重  &#125;  server &#123;    location / &#123;      proxy_pass http://myserver;      proxy_connect_timeout 10;    &#125;  &#125;&#125;\n\n","categories":["运维"],"tags":["nginx"]},{"title":"nginx > location 指令","url":"/2025/09/27/%E8%BF%90%E7%BB%B4-nginx-location%E6%8C%87%E4%BB%A4/","content":"location 指令语法location [匹配模式] URI模式 {    # 匹配成功后执行的配置（如反向代理、静态文件映射等）    配置项;}\n顺序即为优先级 &gt;&gt;&gt;&gt;\n\n\n\n匹配模式符号\n模式名称\n匹配规则\n\n\n\n=\n精确匹配\n仅匹配 URI 完全等于 URI模式 的请求，优先级最高\n\n\n^~\n前缀匹配（优先）\n匹配以 URI模式 开头的请求，不进行正则匹配，优先级次之\n\n\n~ &#x2F; ~*\n正则匹配\n~ 区分大小写优先级高于不区分大小写，~* 不区分大小写，匹配符合正则表达式的 URI\n\n\n无符号\n前缀匹配（普通）\n匹配以 URI模式 开头的请求，优先级低于 ^~，若有正则匹配则优先正则\n\n\nserver &#123;    listen 80;    server_name example.com;    # 1. 精确匹配：仅匹配 / （根路径）    location = / &#123;        return 200 &quot;精确匹配根路径&quot;;    &#125;    # 2. 前缀优先匹配：匹配以 /static/ 开头的请求（如 /static/css/main.css）    location ^~ /static/ &#123;        root /usr/share/nginx/html; # 静态文件根目录    &#125;    # 3. 正则匹配：匹配以 .html 结尾的请求（区分大小写）    location ~ \\.html$ &#123;        return 200 &quot;正则匹配 HTML 文件&quot;;    &#125;    # 4. 普通前缀匹配：匹配以 /api 开头的请求（如 /api/user、/api/order）    location /api &#123;        proxy_pass http://127.0.0.1:3000; # 反向代理到后端服务    &#125;    # 5. 普通前缀匹配：最长匹配兜底（所有未匹配的请求）    location / &#123;        return 404 &quot;未找到匹配的路径&quot;;    &#125;&#125;\n","categories":["运维"],"tags":["nginx"]},{"title":"随笔24/8/2","url":"/2024/07/28/%E9%9A%8F%E7%AC%9424_8_2/","content":"font 字体属性的简写时font:italic 700 24px/56px arial, sans-serif;第一个font-style 第二个font-weight 第三个font-size/line-height最后是font-family的列表优先级是先后顺序。注意：font-size &amp; font-family不可省略，否则不会生效。\n禁用按钮cursor:not-allowed;红色禁用标记backgroung-clip:text;当背景为渐变色时，文字会有较好的渐变效果。\n动态传值以及页面动态效果开发的最终方案关于动态传值问题传值问题可以从表单元素的value属性说起，在这个属性中可以储存从后台拿到的值，但是普通的div等页面的元素可以使用自定义数据类型进行动态传值 data-value data-id等 ，要注意这些属性保存的都是字符串，取出时应该用.getAttribute(&#39;data-value&#39;)拿到\n页面动态效果开发如果只是用 js 控制style改变的均为内联样式，这种方式在微调方面效果显著，但是这种方式调节的是元素的内联样式，在需要大型的调整或者动大的变化时这种方式并不适用，应该通过调整元素的类名改变。、\n控制元素类名的方式\n通过 className，每个元素的 className 都是，它的类名，改变时可以直接赋值上新的类名，原来的类名将会被覆盖掉，所以常有这样的操作,来追加类名，但是不能将加号换成减号直接使用。element.className+=&quot;NewClassName&quot; 2.通过 classList,使用 className 调整类名时还是比较麻烦，所以直接用 classList。(1)通过 ClassList 可以获取元素的全部类名;(2)通过 ClassList.remove()可以删除元素的一个或多个类名；(3)通过 ClassList.add()可以向元素添加一个或多个类名;(4)通过 ClassList.lentgh 可以获取到元素类名的数目；(5)通过 ClassList.item(x)可以获取到元素类名索引为 x 的类名;(6)通过 ClassList.toggle()可以为元素切换类，只能有一个类名;(7)通过 ClassList.contains(x)查看元素是否存在类名为”x”的类;！！！添加删除多个类名时记得是用逗号隔开的参数，不能用空格隔开的类名列表。\n\ntextarea 文本域不加处理时用户可以自由拉伸可以加上`resize : none;`取消这个事件。与他自己的闭合标签中不能有任何东西，包括空格。\n\n事件监听设置事件细分有三种方式\n1. 在script标签中\n`&lt;div class=&quot;small&quot; onclick=&quot;(function()&#123;console.log(&#39;第一次点击&#39;)&#125;)()&quot;&gt;domNode&lt;/div&gt;`\n2.快捷绑定\n`&lt;script&gt;domNode.onclick=function()&#123;console.log(&#39;script&#39;)&#125;&lt;/script&gt;`\n3.监听\n``` js\n\ndomNode.addEventListener(‘click’,function(){        console.log(‘第一次点击’)    })    domNode.addEventListener(‘click’,function(){        console.log(‘第二次点击’)    })&#96;&#96;&#96;！！！先后顺序与排序相同，第三种可以绑定多个，前面的会造成覆盖。\n","categories":["随笔"]}]