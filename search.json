[{"title":"js的数组方法","url":"/2025/05/21/JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","content":"介绍JS 数组是极为灵活的数据结构，应用极为广泛，在这些封装好的方法帮助下，可以大大提高开发效率，和代码可读性。\n方法1. arr.push( )   该方法接收一个或多个参数并将所有的参数按顺序插入数组的末尾。   若将数组作为参数传入，不会将传入的数组拆开而是直接加入到原数组中。\n2. arr.forEach(callback )   该方法接收一个回调函数作为参数 ，\n//该方法没有返回值，直接在回调函数内对数组处理即可//其中回调函数的参数分别是遍历到的当前元素 当前元素的索引 被遍历的数组arr.forEach(function (item, index, thisarr) &#123;  //处理元素&#125;);\n\n3. arr.map(callback)   该方法同样接收一个回调函数作为参数，\n//该方法最后返回一个与原数组相同长度的新数组//在回调函数内部可以对原数组处理，其中参数与forEach的回调参数相同const newArr = arr.map(function (item, index, thisarr) &#123;  return result;&#125;);\n\n4. arr.fliter(callback)   该方法也接收一个回调函数为参\n//该方法最后返回一个与原数组相同长度的新数组//在回调函数内返回一个布尔类型的数据决定当前元素是否返回到新数组中//，其中参数与forEach的回调参数相同const newArr = arr.fliter(function (item, index, thisarr) &#123;  return flag;&#125;);\n\n5. arr.findIndex(callback)   该方法接收一个回调函数\n//该方法最后返回一个查找到元素的索引，找不到返回 -1//在回调函数内返回一个布尔类型的数据决定当前元素是否找到了元素//，其中参数与forEach的回调参数相同const newArr = arr.findIndex(function (item, index, thisarr) &#123;  return flag;&#125;);\n\n6. arr.splice(a,b,c )   该方法接收三个参数，第一个是修改的索引，第二个是将要删除的个数，第三个或更多的元素是在要修改位置插入的，这个方法会原地修改数组。\n7. arr.sort(callback)   该方法为所有数组元素进行了排序，按照升序或者降序排列。\n//回调函数的两个参数是数组相邻的两项//a-b&lt;0时升序排列arr.sort(function (a, b) &#123;  return a - b;&#125;);\n\n8. arr.reverse( )   该方法可以直接将数组的元素反转顺序。\n9. arr.shift( )   删除第一个元素并返回该元素。\n10. arr.pop( )删除末尾元素并返回删除的元素。\n\n11. arr.unshift( )在数组起始处添加元素并返回数组长度。\n\n12. arr.join( )可以将数组转化为字符串，并将该字符串返回，传入的字符参数会作为里连接符。\n参数为字符。\n\n13. arr.concat( )传入两个数组合成一个数组并反回新数组。\n\n14. arr.slice( )arr.slice(起始索引，结束索引)\n包含开始不包含结束。\n可以只写一个参数，截取从该元素开始以后的所有元素。\n还可以写负参数，代表截取到倒数第几个元素。\n\n15. arr.includes( )判断传入的元素是否在数组中。\n\n","categories":["js"],"tags":["js基础"]},{"title":"css BEM 规范","url":"/2025/05/21/css%20BEM%20%E8%A7%84%E8%8C%83/","content":"CSS BEM 规范详解BEM（Block, Element, Modifier）是一种结构化的 CSS 命名方法，由 Yandex 团队提出，用于创建可复用、可维护的前端组件。核心思想是将 UI 拆分为独立的块，通过清晰的命名规则建立层级关系。\nBEM 核心概念1. Block（块）\n定义：页面中独立的、有意义的组件（如 header, card, menu）。\n命名：使用单个单词或连字符连接（如 user-card, search-form）。\n\n2. Element（元素）\n定义：块的组成部分，不能独立于块存在（如 navbar__link, card__title）。\n命名：使用双下划线 __ 连接块名和元素名（如 block__element）。\n\n3. Modifier（修饰符）\n定义：改变块或元素的外观、状态或行为（如 button--primary, card--disabled）。\n命名：使用双连字符 -- 连接（如 block--modifier 或 block__element--modifier）。\n\nBEM 命名规则\n使用连字符 - 分隔单词（如 user-card）。\n元素用双下划线 __ 连接块（如 user-card__avatar）。\n修饰符用双连字符 -- 连接（如 user-card--highlighted）。\n避免嵌套元素超过两层（如 block__elem1__elem2 不推荐）。\n\n","categories":["代码规范"],"tags":["代码规范"]},{"title":"markdown语法","url":"/2025/07/07/markdown%20%E8%AF%AD%E6%B3%95/","content":"markdown语法标题语法根据# 号个数,每个# 号都代表一级标题.根据自己的层次结构决定使用几个#号。一般是有递进规律，一个井号的只用一次。\n换行语法在一行的末尾添加两个或者多个空格，\n然后回车可创建一个空行。\n强调语法粗体：请在单词或短语的前后各添加两个星号或下划线。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号。\n斜体：与粗体类似，可使用一个星号将想要斜体效果的部分引上。\n注意！！！： 可以使用三星号将想要特殊效果的部分引起来，代表斜体和粗体都加上了。\n引用语法\n用大于号代表引用,块引用就是将所有的行前都加上大于号\n\n嵌套引用也是支持的\n\n\n列表语法有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n\n\n\n\n\n无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n\n\n\n\n\n代码语法反引号： printf(&quot;hello world&quot;); 行代码\n围栏式代码块： 用三个反引号跟上代码语言，最后由三个反引号收尾。\npublic class Main &#123;    public static void main(String[] args) &#123;    System.out.println(&quot;hello world &quot;);    &#125;&#125;\n\n分割线语法\n要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。\n\n链接语法中括号加小括号语法 中括号内写名称（随便写） 小括号内写地址\n百度\n图片语法与链接语法类似但是要注意前面有个叹号。\n![图片](图片地址)\n表格语法用竖杠代表表格分割  |\n\n&gt;| 表头     | 表头 |&gt;|: -----------  :|: ----------- :| //在此可进行格式控制，加上：代表向左对齐或者向右对齐，都加时居中对齐, - 的数量与表格布局无关&gt;| Paragraph   | Text        |\n\n\n\n\n姓名\n班级\n年龄\n\n\n\n张三\n计科233\n18\n\n\n !!!注意 \n\n\n列表标题语法和需要在符号后加空格才会生效。\n所有格式控制符号一定是英文符号。\n有些找不到的键符可以在功能键下边那一行找，例如反引号在左上角。\n可以使用markdown编译器。 本地的 typora 或者是多端共享数据放在厂商服务器上的 语雀 ；自由选择编译器。可以在编译器上写好之后往博客上粘贴。\n我这里只是列举了简单的语法的基本使用，其他语法可以自行了解。\nmarkdown官网\n在word或者编译器中直接跳转链接需要使用ctrl键和鼠标点击。\n\n","categories":["学习笔记"],"tags":["学习笔记"]},{"title":"git 基础命令","url":"/2025/08/05/git-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","content":"git 基础命令1. 配置不加尖括号内的东西可以查看相关配置。\n**git config [ –global ] user.name &lt;”your-name”&gt; :**设置名字\ngit config [–global] user.name &lt;”your-name”&gt; : 设置邮箱\n2. 启动\ngit init [project-name]: 创建或者（不加参数时）在当前目录初始化一个git代码库。\ngit clone url: 下载一个项目和它的整个代码历史。\n\n3. 日常操作\ngit init: 初始化仓库，默认 master .\n_git add .:_提交所有文件修改到缓存区\n_git add &lt;文件路径加文件全名&gt;：_提交某些文件到缓存区\ngit status: 查看当前分支的状态\ngit diff: 展示文件在不同版本间的差异，不加参数时，会显示工作区和暂存区的文件差异。\ngit diff [–staged | –cached]: 显示添加到暂存区但是还未提交的修改内容。\ngit pull &lt;远程仓库名&gt; &lt;远程分支名&gt;: [&lt;本地分支名&gt;]: 拉取远程仓库的分支与本地当前分支合并[与传入参数的分支合并]。\ngit commit -m “&lt;注释&gt;”: 提交代码到本地仓库，并写上提交注释。（必须写注释否则提交失败）\ngit commit -v: 提交时显示所有diff信息\n\n4. 分支操作\ngit branch: 查看本地所有分支\ngit branch -r: 查看远程所有分支\ngit branch -a: 查看本地和远程所有分支\ngit merge &lt;分支名&gt;: 合并分支\ngit merge –abort: 合并分支出现冲突时，取消合并，一切回到合并前的状态\ngit branch &lt;新分支名&gt;: 基于当前分支，新建一个分支\ngit checkout –orphan&lt;新分支名&gt;: 新建一个空分支(会保留之前分支的所有文件)\ngit branch-D&lt;分支名&gt;: 删除本地某个分支\ngit push&lt;远程库名&gt;:&lt;分支名&gt;: 删除远程某个分支\ngit branch &lt;新分支名称&gt; &lt;提交ID&gt;: 从提交历史恢复某个删掉的某个分支\ngit branch -m &lt;原分支名&gt;&lt;新分支名&gt;: 分支更名\ngit checkout &lt;分支名&gt;: 切换到本地某个分支\ngit checkout &lt;远程库名&gt;&#x2F;&lt;分支名&gt;: 切换到线上某个分支\ngit checkout -b &lt;新分支名&gt;: 把基于当前分支新建分支，并切换为这个分支\n\n5. 远程同步\ngit fetch［remote］: 下载远程仓库的所有变动\ngit remote-v: 显示所有远程仓库\ngit pull [remote] [branch]: 拉取远程仓库的分支与本地当前分支合并\ngit fetch: 获取线上最新版信息记录，不合并\ngit push [remote] [branch]: 上传本地指定分支到远程仓库\ngit push [remote］–force: 强行推送当前分支到远程仓库，即使有冲突\ngit push［remote］–all: 推送所有分支到远程仓库\n\n","categories":["学习笔记"],"tags":["学习笔记"]},{"title":"原型和原型链问题探究","url":"/2025/05/21/%E5%8E%9F%E5%9E%8B%E9%97%AE%E9%A2%98/","content":"简介原型知识是前端必不可少的进阶知识之一，掌握好原型知识可以让前端开发中更加游刃有余。\nJS对象对象是一种引用或者说是复合的数据结构。展现形式是键值形式，关于对象有很多内容，本节不做深度探究这个问题。主要探究关于原型有关的问题。\n对象的创建模式1.字面量型  var obj1 = &#123;    name: &quot;Jack&quot;,     age: 26     &#125;2.Object构造函数模式var obj2 = new Object() obj2.name = &quot;Jack&quot; obj2.age = 263.构造函数模式function Test(name, age)&#123;    this.name = name    this.age = age    this.say = function()&#123;        console.log(&#x27;我能说话&#x27;)    &#125;&#125;var obj3 = new Test(&#x27;Jack&#x27;, 26)var obj4 = new Test(&#x27;Rose&#x27;, 25)\n\n原型问题主要是探究构造函数在上面那段代码中，Test 就是构造函数，obj3,obj4 是这个构造函数的实例对象，每个对象都有一个特殊的属性就是原型(prototype),(函数也有原型,函数也是对象）\n注意:1. 显式原型和隐式原型:\n    a. 显式原型用prototype属性表示和查找,这是函数的特有属性,普通对象没有.\n    b. 隐式原型用__proto__属性表示和查找,这是对象的属性,由于函数也是对象,\n    所以每个对象都有这个属性.\n    c. 隐式原型的值指向它构造函数的显式原型的值\n2. Object的原型对象的隐式原型指向null\n3. Function是在浏览器运行时已经创建好了的,是所有的起点.而且它的显式原型与隐式原型相等.\n4. 原型链指的就是隐式原型指向连起来的一条链状结构,在查找时会按照这条链,\n一直向上查找,直到null\n\n原型链\n拓展箭头函数出现的意义是什么?(这个问题不在于探究箭头函数的使用问题.)\n箭头函数是ES6中出现的一种简化写法,\n` say=()=&gt;&#123;&#125;`,箭头函数的出现关键是解决了JS中函数的二义性\n在其他面向对象的语言中在开始时就有类的概念,\n在js中函数不仅可以是指令序列,也可能是一个构造函数用来创建对象\n而箭头函数的出现限制了其只能是指令序列而不是构造函数.优化了代码执行\n\n","categories":["js"],"tags":["js高级"]},{"title":"随笔24/8/2","url":"/2025/05/21/%E9%9A%8F%E7%AC%9424_8_2/","content":"font 字体属性的简写时font:italic 700 24px/56px arial, sans-serif;第一个font-style 第二个font-weight 第三个font-size/line-height最后是font-family的列表优先级是先后顺序。注意：font-size &amp; font-family不可省略，否则不会生效。\n禁用按钮cursor:not-allowed;红色禁用标记backgroung-clip:text;当背景为渐变色时，文字会有较好的渐变效果。\n动态传值以及页面动态效果开发的最终方案关于动态传值问题传值问题可以从表单元素的value属性说起，在这个属性中可以储存从后台拿到的值，但是普通的div等页面的元素可以使用自定义数据类型进行动态传值 data-value data-id等 ，要注意这些属性保存的都是字符串，取出时应该用.getAttribute(&#39;data-value&#39;)拿到\n页面动态效果开发如果只是用 js 控制style改变的均为内联样式，这种方式在微调方面效果显著，但是这种方式调节的是元素的内联样式，在需要大型的调整或者动大的变化时这种方式并不适用，应该通过调整元素的类名改变。、\n控制元素类名的方式\n通过 className，每个元素的 className 都是，它的类名，改变时可以直接赋值上新的类名，原来的类名将会被覆盖掉，所以常有这样的操作,来追加类名，但是不能将加号换成减号直接使用。element.className+=&quot;NewClassName&quot; 2.通过 classList,使用 className 调整类名时还是比较麻烦，所以直接用 classList。(1)通过 ClassList 可以获取元素的全部类名;(2)通过 ClassList.remove()可以删除元素的一个或多个类名；(3)通过 ClassList.add()可以向元素添加一个或多个类名;(4)通过 ClassList.lentgh 可以获取到元素类名的数目；(5)通过 ClassList.item(x)可以获取到元素类名索引为 x 的类名;(6)通过 ClassList.toggle()可以为元素切换类，只能有一个类名;(7)通过 ClassList.contains(x)查看元素是否存在类名为”x”的类;！！！添加删除多个类名时记得是用逗号隔开的参数，不能用空格隔开的类名列表。\n\ntextarea 文本域不加处理时用户可以自由拉伸可以加上`resize : none;`取消这个事件。与他自己的闭合标签中不能有任何东西，包括空格。\n\n事件监听设置事件细分有三种方式\n1. 在script标签中\n`&lt;div class=&quot;small&quot; onclick=&quot;(function()&#123;console.log(&#39;第一次点击&#39;)&#125;)()&quot;&gt;domNode&lt;/div&gt;`\n2.快捷绑定\n`&lt;script&gt;domNode.onclick=function()&#123;console.log(&#39;script&#39;)&#125;&lt;/script&gt;`\n3.监听\n``` js\n\ndomNode.addEventListener(‘click’,function(){        console.log(‘第一次点击’)    })    domNode.addEventListener(‘click’,function(){        console.log(‘第二次点击’)    })&#96;&#96;&#96;！！！先后顺序与排序相同，第三种可以绑定多个，前面的会造成覆盖。\n","categories":["随笔"]},{"title":"打包apk文件","url":"/2025/08/30/%E6%89%93%E5%8C%85apk%E6%96%87%E4%BB%B6/","content":"将 uniapp 项目打包成 安卓手机应用 apk环境准备打包安卓应用，首先需要的编辑器有 Android Studio，hbuilderx.hbuilderx是对 uniapp 应用具有极好的适配。\n云打包通过使用DCloud账号登录后，可以通过 hbx 直接云端打包，打包完成后可以根据提示路径下载apk文件。本文的重点是介绍，本地打包。\n本地打包\n使用 hbuilderx 打开项目，并选择 发行 -&gt; 本地打包 -&gt; 生成本地打包资源 。这一步通常是生成了一个 UNI*** 的文件夹。这个文件夹里就是本地的打包资源。\n打开 Android Studio ，新建项目，选择导入项目，选择 android&#x2F;app 文件夹。\n将证书文件复制到 android&#x2F;app 文件夹下。 android 证书通常是 .keystore 或者 .jks 文件。\n在这个目录下 找到 build.gradle 文件，配置证书路径密码。\n将android 文件夹导入到 android studio 中。\n点左侧的菜单栏选择 Build-&gt; Generate App Bundles or APKs  -&gt; Generate APKs\n\nothers！配置 appid 在 android&#x2F;app&#x2F;assets&#x2F;data&#x2F;dcloud_control.xml  文件中 UNI*** 格式的appid 配置。\n！需要在dcloud 账号中申请appid,注册并且完成认证，和创建项目。才能完成云打包。\n！获取安卓证书：获取安卓证书\n","categories":["环境&配置"],"tags":["环境&配置"]},{"title":"picgo+github 配置个人图床","url":"/2025/07/29/picgo+github%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/","content":"使用场景（需求）前端使用 img 标签时可以直接将 src 换成网络路径直接展示，还有就是最常用的 md 中的图片插入，可以只需要在写的时候写上路径就能在任何地方展示。\n配置方法\n注册一个 github 账号，在设置中找到 token 选择 classic token\n将第一个作为仓库勾选上，生成\n记住你的 token 它只会出现这一次，以后你将无法访问到它。\n\npicgo 设置\n","categories":["环境&配置"],"tags":["环境&配置"]}]