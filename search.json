[{"title":"伪类与伪元素","url":"/2025/08/30/css-%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0/","content":"伪类和伪元素一、核心区别：操作对象不同\n\n\n维度\n伪类（Pseudo-class）\n伪元素（Pseudo-element）\n\n\n\n操作对象\n对已有元素在特定状态或场景下的样式修饰\n创建不存在于 DOM 中的虚拟元素并设置样式\n\n\n本质\n元素的“状态&#x2F;场景”（如 hover、first-child）\n元素的“虚拟部分”（如首字母、前后内容）\n\n\n语法\n单冒号 :（如 :hover）\n双冒号 ::（CSS3 规范，兼容兼容旧浏览器兼容单冒号）\n\n\n数量限制\n一个元素可同时应用多个伪类（如 :hover:active）\n一个元素通常同时应用多个伪元素（仅能有一个）\n\n\n\n注意：  关于上表中的数量限制， button:hover:active:focus 是伪类可以这样设置叠加状态，而伪元素在同一时刻只需对一个虚拟部分设置样式。\n\n二、伪类（Pseudo-class）：修饰元素的特殊状态伪类用于选中处于特定状态或满足特定条件的元素，这些元素在 DOM 中真实存在，只是样式会根据状态变化。\n常见伪类及作用\n状态伪类：根据元素交互状态修饰\n\n:hover：鼠标悬停在元素上时\n:active：元素被点击（按下未松开）时\n:focus：元素获得焦点（如输入框被选中）时\n:visited：链接被访问后\n\n\n结构伪类：根据元素在 DOM 中的位置选中\n\n:first-child：父元素的第一个子元素\n:last-child：父元素的最后一个子元素\n:nth-child(n)：父元素的第 n 个子元素（n 可写公式，如 2n 表示偶数位）\n:only-child：父元素中唯一的子元素\n\n\n其他伪类：\n\n:empty：选中没有子元素的元素\n:checked：选中被勾选的表单元素（如单选框、复选框）\n:disabled：选中禁用状态的表单元素\n\n\n\n三、伪元素（Pseudo-element）：创建虚拟元素伪元素用于在元素的特定位置创建虚拟内容（这些内容不在 DOM 中），并为其设置样式。\n常见伪元素及作用\n::before：在元素内容前插入虚拟元素\n\n::after：在元素内容后插入虚拟元素\n\n必须配合 content 属性使用（即使值为空 &quot;&quot;），常用于添加装饰性内容（如图标、分隔线）。\n\n\n::first-letter：选中元素第一个字符（仅用于块级元素）\n\n::first-line：选中元素第一行文本（仅用于块级元素）\n\n::selection：选中用户鼠标选中的文本\n\n\n四、总结：关键区分点\n是否存在于 DOM：\n\n伪类修饰的是 DOM 中真实存在的元素（基于状态&#x2F;位置）。\n伪元素创建的是不存在于 DOM 的虚拟元素（如 ::before 是额外生成的）。\n\n\n用法场景：\n\n伪类：处理元素的交互状态（如 hover）或结构关系（如 first-child）。\n伪元素：处理元素的部分内容样式（如首字母）或添加装饰性内容（如 before&#x2F;after）。\n\n\n语法规范：\n\n伪类用单冒号 :（CSS3 兼容旧写法）。\n伪元素推荐用双冒号 ::（CSS3 新增，区别于伪类），但旧浏览器（如 IE8）仅支持单冒号。\n\n\n\n","categories":["css"],"tags":["css"]},{"title":"js的数组方法","url":"/2024/08/29/js-JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","content":"介绍JS 数组是极为灵活的数据结构，应用极为广泛，在这些封装好的方法帮助下，可以大大提高开发效率，和代码可读性。\n方法1. arr.push( )   该方法接收一个或多个参数并将所有的参数按顺序插入数组的末尾。   若将数组作为参数传入，不会将传入的数组拆开而是直接加入到原数组中。\n2. arr.forEach(callback )   该方法接收一个回调函数作为参数 ，\n//该方法没有返回值，直接在回调函数内对数组处理即可//其中回调函数的参数分别是遍历到的当前元素 当前元素的索引 被遍历的数组arr.forEach(function (item, index, thisarr) &#123;  //处理元素&#125;);\n\n3. arr.map(callback)   该方法同样接收一个回调函数作为参数，\n//该方法最后返回一个与原数组相同长度的新数组//在回调函数内部可以对原数组处理，其中参数与forEach的回调参数相同const newArr = arr.map(function (item, index, thisarr) &#123;  return result;&#125;);\n\n4. arr.fliter(callback)   该方法也接收一个回调函数为参\n//该方法最后返回一个与原数组相同长度的新数组//在回调函数内返回一个布尔类型的数据决定当前元素是否返回到新数组中//，其中参数与forEach的回调参数相同const newArr = arr.fliter(function (item, index, thisarr) &#123;  return flag;&#125;);\n\n5. arr.findIndex(callback)   该方法接收一个回调函数\n//该方法最后返回一个查找到元素的索引，找不到返回 -1//在回调函数内返回一个布尔类型的数据决定当前元素是否找到了元素//，其中参数与forEach的回调参数相同const newArr = arr.findIndex(function (item, index, thisarr) &#123;  return flag;&#125;);\n\n6. arr.splice(a,b,c )   该方法接收三个参数，第一个是修改的索引，第二个是将要删除的个数，第三个或更多的元素是在要修改位置插入的，这个方法会原地修改数组。\n7. arr.sort(callback)   该方法为所有数组元素进行了排序，按照升序或者降序排列。\n//回调函数的两个参数是数组相邻的两项//a-b&lt;0时升序排列arr.sort(function (a, b) &#123;  return a - b;&#125;);\n\n8. arr.reverse( )   该方法可以直接将数组的元素反转顺序。\n9. arr.shift( )   删除第一个元素并返回该元素。\n10. arr.pop( )删除末尾元素并返回删除的元素。\n\n11. arr.unshift( )在数组起始处添加元素并返回数组长度。\n\n12. arr.join( )可以将数组转化为字符串，并将该字符串返回，传入的字符参数会作为里连接符。\n参数为字符。\n\n13. arr.concat( )传入两个数组合成一个数组并反回新数组。\n\n14. arr.slice( )arr.slice(起始索引，结束索引)\n包含开始不包含结束。\n可以只写一个参数，截取从该元素开始以后的所有元素。\n还可以写负参数，代表截取到倒数第几个元素。\n\n15. arr.includes( )判断传入的元素是否在数组中。\n\n","categories":["js"],"tags":["js"]},{"title":"js中时间的处理","url":"/2024/09/07/js-js%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E5%A4%84%E7%90%86/","content":"介绍js 中对时间（Date）已经有了十分完备的方法，你完全可以根据这些原生的方法封装出一个你想要的时间的格式。\n转换方法1. 转化为时间戳\n时间戳:指的是自 1970 年 1 月 1 日 00:00:00 UTC 起至指定日期所经过的毫秒数。\n\n转换方法： getTime()  传入日期 &#x3D;&#x3D;&gt; 时间戳\nconst date = new Date();const timestamp = date.getTime();console.log(&#x27;时间戳:&#x27;, timestamp);\n2. 转化为本地时间字符串转化方法： localTimeString() Date &#x3D;&#x3D;&gt; 本地语言习惯的时间字符串\nconst date = new Date();const options = &#123;year: &#x27;numeric&#x27;,month: &#x27;long&#x27;,day: &#x27;numeric&#x27;,hour: &#x27;numeric&#x27;,minute: &#x27;numeric&#x27;,second: &#x27;numeric&#x27;,timeZoneName: &#x27;short&#x27; &#125;;const formattedTime = date.toLocaleString(&#x27;zh-CN&#x27;, options);console.log(&#x27;自定义格式本地时间字符串:&#x27;, formattedTime);\n3. 转换为 Date 对象转化方法： new Date(str)  将时间字符串传到 str 位置。\n内置方法\n**toDateString()**，把 Date 对象的日期部分转换为字符串。&#x2F;&#x2F;‘Sat May 06 2025’\n**toTimeString()**，把 Date 对象的时间部分转换为字符串。&#x2F;&#x2F;‘14:05:29 GMT+0800 (中国标准时间)’\n**toGMTString()**，获取格林尼治时间字符串。&#x2F;&#x2F;‘Sat, 06 May 2025 06:03:42 GMT’\n**toString()**，把 Date 对象转换为字符串。&#x2F;&#x2F;‘Sat May 06 2025 14:00:02 GMT+0800 (中国标准时间)’\n**toUTCString()**，根据世界时(UTC)，把 Date 对象转换为字符串。&#x2F;&#x2F;‘Sat, 06 May 2025 06:07:58 GMT’\n**toLocaleString()**，根据本地时间格式，把 Date 对象转换为字符串。&#x2F;&#x2F;‘2025&#x2F;5&#x2F;6 14:08:56’\n**toLocaleDateString()**，根据本地时间格式，把 Date 对象的日期部分转换为字符串。&#x2F;&#x2F;‘2025&#x2F;5&#x2F;6’\n**toLocaleTimeString()**，根据本地时间格式，把 Date 对象的时间部分转换为字符串。&#x2F;&#x2F;‘14:10:16’\n**toJSON()**，将 Date 对象转换为字符串，并格式化为 JSON 时间格式。&#x2F;&#x2F;‘2025-05-06T06:10:51.797Z’\n**toISOString()**，使用 ISO 标准返回 Date 对象的字符串格式。&#x2F;&#x2F;‘2025-05-06T06:12:01.451Z’\n\n","categories":["js"],"tags":["js"]},{"title":"picgo+github 配置个人图床","url":"/2025/09/09/picgo+github%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/","content":"使用场景（需求）前端使用 img 标签时可以直接将 src 换成网络路径直接展示，还有就是最常用的 md 中的图片插入，可以只需要在写的时候写上路径就能在任何地方展示。\n配置方法\n注册一个 github 账号，在设置中找到 token 选择 classic token\n将第一个作为仓库勾选上，生成\n记住你的 token 它只会出现这一次，以后你将无法访问到它。\n\npicgo 设置\n","categories":["环境&配置"],"tags":["环境&配置"]},{"title":"原型和原型链问题探究","url":"/2024/08/29/js-%E5%8E%9F%E5%9E%8B%E9%97%AE%E9%A2%98/","content":"简介原型知识是前端必不可少的进阶知识之一，掌握好原型知识可以让前端开发中更加游刃有余。\nJS对象对象是一种引用或者说是复合的数据结构。展现形式是键值形式，关于对象有很多内容，本节不做深度探究这个问题。主要探究关于原型有关的问题。\n对象的创建模式1.字面量型  var obj1 = &#123;    name: &quot;Jack&quot;,     age: 26     &#125;2.Object构造函数模式var obj2 = new Object() obj2.name = &quot;Jack&quot; obj2.age = 263.构造函数模式function Test(name, age)&#123;    this.name = name    this.age = age    this.say = function()&#123;        console.log(&#x27;我能说话&#x27;)    &#125;&#125;var obj3 = new Test(&#x27;Jack&#x27;, 26)var obj4 = new Test(&#x27;Rose&#x27;, 25)\n\n原型问题主要是探究构造函数在上面那段代码中，Test 就是构造函数，obj3,obj4 是这个构造函数的实例对象，每个对象都有一个特殊的属性就是原型(prototype),(函数也有原型,函数也是对象）\n注意:1. 显式原型和隐式原型:\n    a. 显式原型用prototype属性表示和查找,这是函数的特有属性,普通对象没有.\n    b. 隐式原型用__proto__属性表示和查找,这是对象的属性,由于函数也是对象,\n    所以每个对象都有这个属性.\n    c. 隐式原型的值指向它构造函数的显式原型的值\n2. Object的原型对象的隐式原型指向null\n3. Function是在浏览器运行时已经创建好了的,是所有的起点.而且它的显式原型与隐式原型相等.\n4. 原型链指的就是隐式原型指向连起来的一条链状结构,在查找时会按照这条链,\n一直向上查找,直到null\n\n原型链\n拓展箭头函数出现的意义是什么?(这个问题不在于探究箭头函数的使用问题.)\n箭头函数是ES6中出现的一种简化写法,\n` say=()=&gt;&#123;&#125;`,箭头函数的出现关键是解决了JS中函数的二义性\n在其他面向对象的语言中在开始时就有类的概念,\n在js中函数不仅可以是指令序列,也可能是一个构造函数用来创建对象\n而箭头函数的出现限制了其只能是指令序列而不是构造函数.优化了代码执行\n\n","categories":["js"],"tags":["js"]},{"title":"react hooks","url":"/2025/10/11/react-react-hooks/","content":"react hooks (内置的钩子)什么是 hooks?    增强了函数组件的功能。    在没有 hooks 时，函数组件是没有状态、生命周期、ref 等。通过 hooks 使函数组件也具有这些能力。    在没有 hooks 时，函数组件是缺少部分功能的，只有 class 类组件才拥有这些功能。因此函数组件性能更优，更符合 React 的设计，所以要尽可能的用函数组件。\nuseState用于定义响应式变量，和改变变量的方式,可以在数据更新时更新页面。只要 state 发生变化,函数组件会重新渲染。而且会递归的渲染子组件，也会重新渲染。\nimport &#123; useState &#125; from &#x27;react&#x27;;function Example() &#123;    const [count, setCount] = useState(0);    const increment = () =&gt; &#123;        setCount(count =&gt; count+1)    &#125;    return &lt;&gt;        &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;        &lt;button onClick=&#123;increment&#125;&gt;            +        &lt;/button&gt;        &lt;button onClick=&#123;() =&gt; &#123;setCount(666)&#125;&#125;&gt;            set count = 666        &lt;/button&gt;    &lt;/&gt;&#125;\n\nuseMemo核心是缓存计算值，对于多次重复使用计算值的情况，对应用进行性能优化。针对那些特别昂贵的计算。如果依赖数组传入空数组，函数只调用一次。也就是只会计算一次结果，之后的值都来自缓存。\nimport React, &#123; useMemo &#125; from &#x27;react&#x27;;function MyComponent(&#123; a, b &#125;) &#123;  const expensive = useMemo(() =&gt; &#123;    let sum = 0;    for (let i = 0; i &lt; a; i++) &#123;      sum += 1;      console.log(sum);    &#125;    return [sum];  &#125;, [a]);  console.log(&quot;组件渲染完成！&quot;);  return &lt;h1&gt;&#123;expensive&#125;&lt;/h1&gt;;&#125;\n\nuseEffect用于处理组件中的副作用（如数据获取、订阅、手动修改 DOM 等）\n","categories":["react"],"tags":["react"]},{"title":"react 基本语法","url":"/2025/12/20/react-react%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","content":"react 基本语法介绍react 是一个用于构建用户界面的 JavaScript 库。是和 vue 类似的前端框架，也有一些相似的地方。用于基于UI组件构建用户界面。React的特点：\n\n组件化：React将UI拆分为独立、可重用的组件，每个组件都有自己的逻辑和控制。\n声明式编程：React采用声明式编程范式，开发人员只需描述应用的每个状态下的UI，React会自动处理UI的更新。\n虚拟DOM：React使用虚拟DOM来提高性能，通过对比虚拟DOM的变化，最小化实际DOM操作。\n高效的状态管理：React通过状态（State）和属性（Props）来管理数据，确保数据流动的单向性。\n\n创建项目\n可以使用官方脚手架 create-react-app 创建项目（基于 webpack 构建）。\n使用 vite 创建项目。\n\n基本语法1. 渲染模板语法和注释react 中的模板语法与 vue 不同，并没有使用大胡子语法，而是使用 JSX 语法。只用了一个 {} 来包裹 JS 代码或者需要渲染的变量。\nimport &#123; useState &#125; from &quot;react&quot;;export const DemoRenderComment = (): JSX.Element =&gt; &#123;    const [name,setName] = useState(&quot;qqq&quot;);  return (    &lt;div&gt;      &lt;h1&gt;&#123;name&#125;&lt;/h1&gt;        &#123;/* &lt;AButton onClick=&#123;() =&gt; setName(&quot;www&quot;)&#125;&gt;修改name&lt;/AButton&gt; */&#125; // 这是 JSX 内部的 单行注释    &lt;/div&gt;  );&#125;;\n\n注释:  &#123;/* 这是 JSX 内部的单行注释 */&#125; 不过在我看来，任何代码的注释都不需要特别记忆，在 vscode 中可以直接用 ctrl + / 来生成对应代码的注释，使用几次也就知道注释的方式了，当然在实际书写中也大概是用这个快捷键生成更好一点。\n2. 条件渲染 和 循环渲染react 中有两种方式进行条件渲染：\n\n三目运算符\nif 语句\n\n一般简单的直接使用三目运算符就可以了，但是对于复杂逻辑，if 语句会更清晰。\n\n如果要控制类名 要使用 className 属性。\n\n循环渲染一般用数组 map 方法进行。\nimport &#123; useState &#125; from &quot;react&quot;;export default function DemoRenderComment(): JSX.Element &#123;  const [name, setName] = useState(&quot;qqq&quot;);  const [renderType, setRenderType] = useState(&quot;CAR&quot;);  const [isShow] = useState(true);  const dataList = [    &#123;        name:&quot;111&quot;,        age:12    &#125;,    &#123;        name:&quot;222&quot;,        age:13    &#125;,    &#123;        name:&quot;333&quot;,        age:14    &#125;  ]  return (    &lt;&gt;      &#123;      renderType === &quot;CAR&quot; ? (        &lt;&gt;          &lt;h1&gt;&#123;name&#125;&lt;/h1&gt;          &lt;AButton onClick=&#123;() =&gt; setName(&quot;www&quot;)&#125;&gt;修改name&lt;/AButton&gt;          &lt;AButton onClick=&#123;() =&gt; setRenderType(&quot;CR&quot;)&#125;&gt;Condition Render&lt;/AButton&gt;        &lt;/&gt;      ) : renderType === &quot;CR&quot; ?       (        &lt;&gt;          &#123;isShow &amp;&amp; &lt;h1&gt;&#123;&quot;条件渲染&quot;&#125;&lt;/h1&gt;&#125;          &lt;AButton onClick=&#123;() =&gt; setRenderType(&quot;LR&quot;)&#125;&gt;Loop Render&lt;/AButton&gt;        &lt;/&gt;      ):(            dataList.map((item) =&gt; (                &lt;p key=&#123;item.name&#125;&gt;&#123;item.name&#125;&lt;/p&gt;            ))        )    &#125;    &lt;/&gt;  );&#125;;\n\n3. () {}小括号在 react 的渲染中主要是为了分组和提高可读性。    在 return 多个同级元素时如果不分组，会报错。    在写一些长的逻辑时，可以放在小括号中。提高代码的可读性。大括号在 react 中主要是为了嵌入 js 表达式    在嵌入表达式时如果没有大括号会报错。    反过来，只要你需要嵌入 js 表达式的时候，都可以使用大括号，比如属性绑定变量值，事件绑定。\n4. 事件绑定绑定事件也是 js 的表达式，但是要注意绑定的事件，尽管跟原生事件类似，但是他用的是小驼峰命名事件。\n&lt;div onClick=&#123;() =&gt; &#123;&#125;&#125;&gt;Click Me&lt;/div&gt;\n\n函数组件和类组件可见独立行文。\n函数组件的hooks可见 react-hooks.\n组件通信可见独立行文，react 组件通信。\nreact 中使用 样式1. 行内样式和类样式import &quot;./css-in-react.scss&quot;;export default function CssInReact(): JSX.Element &#123;    const style = &#123;        color: &quot;red&quot;    &#125;    return (        &lt;div&gt;            &lt;h2&gt;行内样式和类样式&lt;/h2&gt;            &lt;div style=&#123;&#123; color: &quot;red&quot; &#125;&#125;&gt;                行内样式            &lt;/div&gt;            &lt;div style=&#123;style&#125;&gt;                行内样式            &lt;/div&gt;            &lt;div className=&quot;demo-css-style&quot;&gt;                类样式            &lt;/div&gt;        &lt;/div&gt;    );&#125;;\n\n类样式就是控制类名，当然这样引入的肯定是全局样式，性能比行内样式更高。行内样式既可以是直接写的一个样式对象，也可以是写成的对象直接引入。\n2. 模块化样式「module」模块化样式，就是将样式文件写成 .module.[css|scss] 文件，然后引入的时候作为一个对象，对象中的属性就是类名。\nimport styles from &quot;./demo.module.scss&quot;;export default function CssInReact(): JSX.Element &#123;    return (        &lt;div&gt;            &lt;h2&gt;模块样式&lt;/h2&gt;            &lt;div className=&#123;styles.container&#125;&gt;                模块样式            &lt;/div&gt;            &lt;button className=&#123;styles.button&#125;&gt;                模块样式按钮            &lt;/button&gt;        &lt;/div&gt;    );&#125;;\n\n在 vite 为构建工具时，默认就开启了模块样式，所以不需要特殊配置。只需要安装 scss-loader 和相关的模块就可以了。在 webpack 中，需要配置 module.rules。(create-react-app 默认使用的是 webpack)\nmodule.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.module\\.scss$/,        use: [          &#x27;style-loader&#x27;,          &#123;            loader: &#x27;css-loader&#x27;,            options: &#123;              modules: &#123;                mode: &#x27;local&#x27;,                localIdentName: &#x27;[name]__[local]--[hash:base64:5]&#x27;,                exportLocalsConvention: &#x27;camelCase&#x27;, // 将 kebab-case 转换为 camelCase                auto: true // 自动检测模块文件              &#125;,              importLoaders: 1 // 在 css-loader 之前应用的 loader 数量            &#125;          &#125;,          &#123;            loader: &#x27;sass-loader&#x27;,            options: &#123;              // 可以添加 sass 选项              sassOptions: &#123;                indentWidth: 2,                includePaths: [&#x27;src/styles&#x27;]              &#125;            &#125;          &#125;        ]      &#125;    ]  &#125;&#125;;\n\n两个特殊的选择器：\n\n:global :global(.className)，这样标记的类名，不会被模块化。\n:local :local(.className)，这样标记的类名，会被模块化。(不常用)\n\n3. css in js这是一种思想，也一些实现了的库，主要是通过用 js 生成样式，然后插入到页面中。\n4. 动态样式我们可以使用一些布尔变量为组件设置对象类型的样式，随着布尔变量的改变，组件的样式也会改变。这是非常常用的一种方式。\n","categories":["react"],"tags":["react"]},{"title":"react 组件通信","url":"/2025/12/17/react-react%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","content":"react 组件通信介绍组件通信，就是组件之间如何进行数据传递。和 vue 有一定的相似之处，但是没有 vue 中那么多的方式。当然，在大部分情况下，我们并不需要那么多种的通信方式。\n通信方式总结1. 父组件向子组件传递数据通过 props 属性传递数据给子组件。子组件可以接受 props 属性，然后使用 props 属性中的数据。\n2. 子组件向父组件传递数据定义一个自定义事件 onSendData 事件，在子组件中定义一个方法，将数据通过事件传递给父组件。\n// father.tsx 父组件import &#123; useState &#125; from &#x27;react&#x27;;import Child from &#x27;./child&#x27;;export default function Father(): JSX.Element &#123;    const [message,setMessage] = useState(&#x27;响应式数据&#x27;);    const handleSendData = (data: string) =&gt; &#123;       setMessage(data);    &#125;    return (        &lt;div&gt;            &lt;h2&gt;父组件&lt;/h2&gt;            &lt;p&gt;&#123;message&#125;&lt;/p&gt;            &lt;Child name=&quot;父组件姓名&quot; onSendData=&#123;handleSendData&#125; /&gt;        &lt;/div&gt;    );&#125;// child.tsx 子组件export default function Child(props: &#123; name: string ; onSendData: (data: string) =&gt; void &#125;): JSX.Element &#123;    const handleSend = () =&gt; &#123;        props.onSendData(&#x27;子组件调用了父组件&#x27;);    &#125;    return (        &lt;div&gt;            &lt;h2&gt;子组件&lt;/h2&gt;            &lt;p&gt;prop数据-姓名：&#123;props.name&#125;&lt;/p&gt;            &lt;button onClick=&#123;handleSend&#125;&gt;调用父组件&lt;/button&gt;        &lt;/div&gt;    );&#125;\n\n3. 祖先组件向后代组件传递数据useContext hooks 实现。\n\n创建一个 Context 对象。\n使用 Provider 组件将数据提供给后代组件。\n使用 useContext 获取数据。\n\n// context.tsimport &#123; createContext &#125; from &#x27;react&#x27;;// 创建 Context 容器，默认值为 &#x27;light&#x27;（可选，未找到 Provider 时使用）const ThemeContext = createContext(&#x27;light&#x27;);export default ThemeContext;// 祖先组件import &#123; useState, useContext &#125; from &#x27;react&#x27;;import ThemeContext from &#x27;./theme-context&#x27;;export default function Father(): JSX.Element &#123;    const theme = useContext(ThemeContext);    return (            &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;            &lt;Child  /&gt;            &lt;/ThemeContext.Provider&gt;    );&#125;// 后代组件import &#123; useContext &#125; from &#x27;react&#x27;;import ThemeContext from &#x27;./theme-context&#x27;;export default function Child(props: &#123; name: string ; onSendData: (data: string) =&gt; void &#125;): JSX.Element &#123;    const theme = useContext(ThemeContext);    return (        &lt;div&gt;            &lt;p&gt;prop数据-姓名：&#123;props.name&#125;&lt;/p&gt;            &lt;p&gt;context数据 当前主题：&#123;theme&#125;&lt;/p&gt;        &lt;/div&gt;    );&#125;\n\n4. 类似于事件总线(vue中)使用事件订阅，即一个发布者，一个或多个订阅者。来实现组件通信。整体上就是发布事件然后订阅来实现不同的组件之间的通信。懒得写了，用的不多，还得引入个 event 库。\n","categories":["react"],"tags":["react"]},{"title":"react 编写规范","url":"/2025/12/24/react-react%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/","content":"react 编写规范介绍这里或许是一些固定的语法，或许是一些建议，不过有些时候约定也是为了更少出现语法错误或者更利于开发者的开发和维护。因此，最好严格遵守这些规定来完成jsx 或者 tsx 代码的编写。\njsx&#x2F;tsx 要求1. 必须只返回一个 dom 元素类似于 vue2 中只能有一个根节点，当然这个根节点也可以是 react 提供的空标签 &lt;&gt;&lt;/&gt;。\n2. 组件命名使用大驼峰命名法组件命名使用大驼峰命名法，比如 &lt;MyComponent /&gt;。\n3. 标签必须闭合所有标签必须闭合，比如 &lt;div&gt;&lt;/div&gt;。\n4. hook 调用必须在顶层hook 只能在函数组件或者自定义 hook 中调用，不能在循环、条件判断或者嵌套函数中调用。\n5. hook 命名必须以 use 开头hook 命名必须以 use 开头，比如 useState。自定义的hook 也必须以 use 开头，比如 useMyHook。\n6. hook 只能在 React 函数中调用hook 只能在 React 组件或者 hooks 中调用，不能在普通的 JavaScript 函数中调用。\n7. 没有子内容的标签必须使用自闭合标签没有子内容的标签必须使用自闭合标签，比如 &lt;input /&gt;，还包括自己定义的组件标签，比如 &lt;MyComponent /&gt;。\n8. 超过一行的 jsx 代码必须使用括号括起来超过一行的 jsx 代码必须使用括号括起来，比如 &lt;div&gt;&#123;name&#125;&lt;/div&gt;。增强可读性。\n","categories":["react"],"tags":["react"]},{"title":"react -> redux","url":"/2025/12/27/react-redux/","content":"redux 在 react 中使用redux 介绍是一个专门用来做状态管理的js库（不是react插件）可以用在vue、react、angular项目中，但基本与react配合使用作用：集中式管理react应用中的多个组件共享的状态\nredux-toolkit 和 react-redux这两个库才是实际上在 react 中使用进行状态管理的库。\n安装\nnpm install @reduxjs&#x2F;toolkit react-redux\n\n概念\n\n\n概念\n作用\n对应 RTK 工具\n\n\n\nStore\n存储全局状态的容器（唯一数据源）\nconfigureStore（创建 Store）\n\n\nSlice\n拆分状态模块（如用户模块、购物车模块）\ncreateSlice（定义切片）\n\n\nReducer\n纯函数，根据 Action 修改状态（不可直接改）\nSlice 内置 reducer 函数\n\n\nAction\n描述状态变化的 “指令”（如 “添加商品”）\nSlice 自动生成 Action Creator\n\n\nDispatch\n发送 Action 给 Reducer 的方法\nuseDispatch（组件中调用）\n\n\nSelector\n从 Store 中读取状态的方法\nuseSelector（组件中读取）\n\n\n使用\n创建 Slice（拆分状态模块）\n创建 Store（存储全局状态的容器）\n全局注入Store\n在组件中使用\n\n// 创建Slice src/store/slice/auth/index.tsimport &#123; createSlice,type Slice&#125; from &#x27;@reduxjs/toolkit&#x27;;import type &#123; PayloadAction &#125; from &#x27;@reduxjs/toolkit&#x27;;export interface UserState &#123;  name: string;  theme: &#x27;light&#x27; | &#x27;dark&#x27;;&#125;const initialState: UserState = &#123;  name:  &#x27;&#x27;,  theme: &#x27;light&#x27;,&#125;;export const authSlice: Slice = createSlice(&#123;  name: &#x27;auth&#x27;,  initialState,  reducers: &#123;    setUser: (state, action: PayloadAction&lt;&#123; name: string &#125;&gt;) =&gt; &#123;      state.name = action.payload.name;    &#125;,    setTheme: (state, action: PayloadAction&lt;&#x27;light&#x27; | &#x27;dark&#x27;&gt;) =&gt; &#123;      state.theme = action.payload;    &#125;,  &#125;,&#125;);export const &#123; setUser, setTheme &#125; = authSlice.actions;export default authSlice.reducer;// 创建Store src/store/index.ts 汇总分片import &#123; configureStore &#125; from &#x27;@reduxjs/toolkit&#x27;;import &#123; authSlice &#125; from &#x27;./slice/auth&#x27;;import &#123; articleSlice &#125; from &#x27;./slice/article&#x27;;const store = configureStore(&#123;  reducer: &#123;    auth: authSlice.reducer,    article: articleSlice.reducer,  &#125;,&#125;);export type RootState = ReturnType&lt;typeof store.getState&gt;;export type AppDispatch = typeof store.dispatch;export default store;// 全局注入Store src/main.tsximport &#123; createRoot &#125; from &quot;react-dom/client&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import App from &quot;@/App&quot;;import ErrorBoundary from &quot;@/layouts/ErrorBoundary&quot;;import store from &quot;@/store&quot;;function setupApp() &#123;  const container = document.getElementById(&quot;root&quot;);  if (!container) return &lt;&gt;请绑定容器&lt;/&gt;;  const root = createRoot(container);  root.render(    &lt;ErrorBoundary&gt;      &lt;Provider store=&#123;store&#125;&gt;        &#123;/* 全局注入Store ，在所有的子组件中都可以使用 store*/&#125;        &lt;App /&gt;      &lt;/Provider&gt;    &lt;/ErrorBoundary&gt;  );&#125;setupApp();// 在组件中使用import &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;import type &#123; RootState &#125; from &quot;../../store&quot;;import &#123; setUser ,type UserState&#125; from &quot;@/store/slice/auth&quot;;function Home() &#123;  const auth: UserState = useSelector((state: RootState) =&gt; state.auth);  const dispatch = useDispatch();  return (    &lt;div className=&quot;f-c flex-col h-screen bg-bg-primary&quot;&gt;        &lt;h2&gt;Auth Slice&lt;/h2&gt;        &lt;p&gt;User Name: &#123;auth.name&#125;&lt;/p&gt;        &lt;p&gt;Theme: &#123;auth.theme&#125;&lt;/p&gt;        &lt;button onClick=&#123;() =&gt; dispatch(setUser(&#123; name: &quot;Jim&quot; &#125;))&#125;&gt;Set User&lt;/button&gt;    &lt;/div&gt;  );&#125;export default Home;\n","categories":["react"],"tags":["react"]},{"title":"react 类组件和函数组件","url":"/2025/12/13/react-%E5%89%AF%E4%BD%9C%E7%94%A8/","content":"react 中的副作用什么是副作用？\n在函数式编程里，副作用（side effect）指函数除了返回值之外，对外部世界产生的影响：修改外部变量、发请求、操作 DOM、读写存储、订阅&#x2F;计时器等。\n\n在 React 中，渲染（render）必须是纯的：只根据 props&#x2F;state 计算出要渲染的 UI，不做任何副作用；一切与外界交互都要放到 React 的“提交阶段（commit）”里，通过 Effect 等机制完成。\n\n\n在 React 里，哪些是副作用常见副作用清单（应该放到 effect 或事件中，而非 render）：\n\n数据请求&#x2F;写入：fetch、axios、IndexedDB、本地存储（localStorage&#x2F;sessionStorage）。\n订阅&#x2F;连接：WebSocket、SSE、EventSource、自定义事件、RxJS 订阅。\n计时器：setTimeout&#x2F;setInterval、requestAnimationFrame。\nDOM 操作：读写布局、手动添加&#x2F;移除事件、第三方非 React 组件初始化&#x2F;销毁。\n日志&#x2F;埋点：console、监控上报。\n突变外部状态：修改全局变量、单例、window、document、全局缓存等。\n路由跳转：navigate（通常在事件里做，或在 effect 中根据状态变化做）。\n\n为什么不能在渲染中做副作用\n渲染可能多次、被中断、回滚（React 18 并发特性 + StrictMode 开发模式会故意二次调用组件的 render &#x2F; mount，以帮助你发现“不纯”的副作用）。\n如果在 render 里发请求&#x2F;改 DOM，会重复执行、产生竞态甚至内存泄漏。\n\n该把副作用放哪优先顺序（官方推荐）：\n\n事件处理器（最好）：用户触发才发生的事（点击发请求&#x2F;写入存储&#x2F;上报），直接放 onClick&#x2F;onChange；不占用渲染生命周期，简单、可控。\n\n**useEffect**（渲染后、异步执行，不阻塞绘制）：根据 state&#x2F;props 的变化去“同步外部世界”：加载数据、订阅、计时器、写存储、日志等。支持清理。\n\nuseLayoutEffect（DOM 提交后、绘制前、同步执行）：需要测量布局、同步修正 DOM（避免闪烁）时用，比如读取元素尺寸然后立即设置样式&#x2F;滚动。\n\n**useInsertionEffect**（极早期，用于样式注入库）：一般只给 CSS-in-JS 库用，业务几乎不用。\n\n\nuseEffect 的工作方式（要点）\n时机：浏览器完成绘制后再执行，不阻塞渲染。\n依赖数组：决定 effect 何时运行&#x2F;重跑；漏依赖会导致“陈旧闭包”。\n清理函数：返回函数在下次重跑前或组件卸载时执行（用来取消订阅、清计时器、Abort 请求）。\nReact 18 StrictMode（仅开发）：会 mount → cleanup → 再 mount，帮你检查 effect 是否能正确清理；生产环境只执行一次。\n\n示例（请求 + 竞态处理）：\nuseEffect(() =&gt; &#123;  const ctrl = new AbortController();  (async () =&gt; &#123;    try &#123;      const res = await fetch(`/api/posts?user=$&#123;userId&#125;`, &#123; signal: ctrl.signal &#125;);      if (!res.ok) throw new Error(&#x27;Network&#x27;);      const data = await res.json();      setPosts(data);    &#125; catch (e) &#123;      if ((e as any).name !== &#x27;AbortError&#x27;) setError(e as Error);    &#125;  &#125;)();  return () =&gt; ctrl.abort();&#125;, [userId]); // 别漏依赖\n\nuseEffect vs useLayoutEffectuseEffect：不阻塞绘制；适合网络、订阅、日志等绝大多数副作用。useLayoutEffect：在绘制前同步执行；适合读写布局、同步 DOM 修正，否则可能闪烁。SSR 场景会有告警（可在客户端条件使用）。\n示例（测量 DOM）：\nconst ref = useRef&lt;HTMLDivElement&gt;(null);useLayoutEffect(() =&gt; &#123;  const r = ref.current!;  const &#123; width &#125; = r.getBoundingClientRect();  r.style.height = width * 0.5625 + &#x27;px&#x27;;&#125;, []);\n\n常见陷阱与最佳实践\n事件里能做的，就别放 effect例如点击“加载更多”→ 在 onClick 里请求即可，而不是 watch 某个 state 再在 effect 请求。\n\n拆分 effect不相关的副作用分开写，避免交叉依赖和重复触发。\n\n依赖数组写全开启 eslint-plugin-react-hooks；如果因性能原因不想重跑，考虑把不稳定的函数用 useCallback、对象用 useMemo 或 用 ref 保存可变值。\n\n避免在 effect 里无条件 setState 造成死循环如果 setState 基于异步结果&#x2F;条件变化，确保依赖正确且不会每次导致同样的更新。\n\n处理异步竞态组件在请求未完成前卸载或依赖变化，要 Abort 或比对请求标识，避免“后到的旧数据覆盖新数据”。\n\n第三方库初始化&#x2F;销毁在 effect 里初始化实例，返回清理函数销毁&#x2F;解绑事件。\n\nSSRuseEffect 不在服务端执行；useLayoutEffect 在 SSR 下会告警，按需改为条件调用或仅在客户端渲染。\n\n把“派生数据”放到 memo 而不是 effect纯计算（由现有 state&#x2F;props 得出）用 useMemo，不要用 effect 去 setState 派生，这会多一次渲染并可能出错。\n\n\n该放事件还是 effect？（速判） 用户动作直接触发：事件（onClick&#x2F;onSubmit…）。 状态&#x2F;路由变化带来的外部同步：effect。 需要读&#x2F;改布局：layout effect。 只是算个新值：memo，而不是 effect + setState。\n实用片段订阅\nuseEffect(() =&gt; &#123;  const sub = bus.on(&#x27;message&#x27;, setMsg);  return () =&gt; sub.off(); // 清理&#125;, []);\n\n计时器\nuseEffect(() =&gt; &#123;  const id = setInterval(() =&gt; setTick(t =&gt; t + 1), 1000);  return () =&gt; clearInterval(id);&#125;, []);\n\n写本地存储（响应 state 变化）\nuseEffect(() =&gt; &#123;  localStorage.setItem(&#x27;theme&#x27;, theme);&#125;, [theme]);\n\n避免陈旧闭包（把可变值放 ref）\nconst latestFilter = useRef(filter);useEffect(() =&gt; &#123; latestFilter.current = filter; &#125;, [filter]);useEffect(() =&gt; &#123;  const id = setInterval(() =&gt; &#123;    doSearch(latestFilter.current); // 始终拿到最新 filter  &#125;, 5000);  return () =&gt; clearInterval(id);&#125;, []);\n\n一句话记忆：\n\n渲染要纯；副作用放事件或 effect；布局相关用 layout effect；依赖写全、及时清理、处理竞态。\n\n","categories":["react"],"tags":["react"]},{"title":"react 类组件和函数组件","url":"/2025/10/08/react-%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/","content":"类组件 &amp; 函数组件首先，类组件和函数组件本质上都是相同的，只是两种不同的编写组件的方式。并且，由于 hooks 的出现，函数在性能和功能上完全可以取代类组件。而且，函数组件也更方便，因此在开发中应该越来越趋近于函数组件，但是也要了解类组件的编写方法，了解 react 的原理。\n类组件类组件通过定义类来定义组件，使用 es6 class 继承 React.Component, 类组件需要自己维护内部的 state。\nclass Example extends React.Component &#123;    constructor(props) &#123;        super(props);        this.state = &#123;            message: &#x27;&#x27;        &#125;;    &#125;    render() &#123;        const &#123; message &#125; = this.state;        return (            &lt;h2&gt;&#123;message&#125;&lt;/h2&gt;            &lt;button onClick=&#123;() =&gt; this.setState(&#123;message : &#x27;React&#x27;&#125;)&#125;&gt;Click&lt;/button&gt;        );    &#125;&#125;\n\n函数组件函数组件通过编写函数，通过函数的方式定义组件，使用 hooks 管理组件内部状态。\nconst Example = (props) =&gt; &#123;    const [message, setMessage] = useState(&#x27;&#x27;);    const onClickHandler = () =&gt; &#123;        setMessage(&#x27;React&#x27;);    &#125;    return (        &lt;h2&gt;&#123;message&#125;&lt;/h2&gt;        &lt;button onClick=&#123;onClickHandler&#125;&gt;Click&lt;/button&gt;    );&#125;\n","categories":["react"],"tags":["react"]},{"title":"mvc mvp mvvm","url":"/2025/11/01/vue-mvc,mvp,mvvm/","content":"MVC -&gt; MVP -&gt; MVVM发展与介绍MVC（Model - View - Controller）MVC基本概念\nModel（模型）：负责处理数据和业务逻辑，比如数据的存储、读取、更新等操作。\nView（视图）：负责展示数据和与用户进行交互，像界面布局、按钮、文本框等。\nController（控制器）：作为 Model 和 View 之间的桥梁，接收用户的输入，调用 Model 进行相应的业务处理，并将处理结果传递给 View 进行展示。\nreact 框架使用 MVC 模式。\n\nMVC工作流程\n用户通过 View 发起请求。\nView 将请求传递给 Controller。\nController 调用 Model 进行业务处理。\nModel 处理完业务逻辑后，将结果返回给 Controller。\nController 将结果传递给 View 进行展示。\n\nMVC优点\n职责分离：将数据处理、界面展示和用户交互逻辑分开，便于代码的维护和扩展。\n可测试性：Model 和 Controller 可以独立进行单元测试。\n\nMVC缺点\nView 和 Controller 耦合度高：View 和 Controller 之间的交互较为紧密，修改其中一个可能会影响到另一个。\n代码复杂度：随着项目规模的增大，Controller 可能会变得非常庞大，包含大量的业务逻辑。\n\nMVP（Model - View - Presenter）MVP基本概念\nModel（模型）：与 MVC 中的 Model 类似，负责处理数据和业务逻辑。\nView（视图）：负责展示数据和与用户进行交互，只负责界面的绘制和事件的触发，不包含任何业务逻辑。\nPresenter（展示器）：作为 Model 和 View 之间的中介，接收 View 的请求，调用 Model 进行业务处理，并将处理结果传递给 View 进行展示。\n\nMVP工作流程\n用户通过 View 发起请求。\nView 将请求传递给 Presenter。\nPresenter 调用 Model 进行业务处理。\nModel 处理完业务逻辑后，将结果返回给 Presenter。\nPresenter 将结果传递给 View 进行展示。\n\nMVP优点\n职责分离更彻底：View 只负责界面展示，Presenter 负责业务逻辑，两者的耦合度更低。\n可测试性强：Presenter 可以独立进行单元测试，不依赖于 View。\n\nMVP缺点\n代码量增加：由于需要额外的 Presenter 层，代码量会有所增加。\n学习成本：对于初学者来说，理解 MVP 模式的概念和实现方式可能需要一定的时间。\n\nMVVM（Model - View - ViewModel）基本概念\nModel（模型）：同样负责处理数据和业务逻辑。\nView（视图）：负责展示数据和与用户进行交互，通过数据绑定机制与 ViewModel 进行关联。\nViewModel（视图模型）：作为 Model 和 View 之间的桥梁，将 Model 中的数据转换为 View 可以展示的格式，并处理 View 中的用户交互事件。\n\n工作流程\nView 通过数据绑定机制从 ViewModel 中获取数据进行展示。\n用户在 View 上进行交互操作，触发 ViewModel 中的相应事件。\nViewModel 调用 Model 进行业务处理。\nModel 处理完业务逻辑后，将结果返回给 ViewModel。\nViewModel 更新自身的数据，View 通过数据绑定机制自动更新界面展示。\n\n优点\n数据绑定：通过数据绑定机制，View 和 ViewModel 之间的交互更加简洁，减少了手动更新界面的代码。\n可测试性高：ViewModel 可以独立进行单元测试，不依赖于 View。\n提高开发效率：开发人员可以专注于业务逻辑的实现，而不需要关注界面的更新。\n\n缺点\n学习成本高：MVVM 模式引入了数据绑定和命令等概念，对于初学者来说学习成本较高。\n性能问题：数据绑定机制可能会带来一定的性能开销，尤其是在处理大量数据时。\n\n总结  mvc 模式在前端的应用并不多，主要是后端的架构方式，当被逐渐优化 mvp 才渐渐被引入到前端的架构当中，后来又演变为 mvvm 在 Vue.js、Angular、React 这些框架中广泛使用\nMVVM 模型在 vue 中\n\n实现数据与视图的分离。\n通过数据来驱动视图，开发者只需要关心数据变化，DOM操作被封装了\n\n","categories":["vue"],"tags":["vue"]},{"title":"vue2 和 vue3 的区别","url":"/2025/11/13/vue-vue2%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"vue3和vue2的区别前景介绍与其再细究vue3的语法，不如看看 vue3 的主要变化。将 vue2 和 vue3 联合起来对比学习。\n不同点1. 构建工具的变化vue2 使用的是 webpack 构建，而 vue3 使用的是 vite 构建。主要的区别在于这两个构建工具的区别。体现在实际感受中就是 vite 更快，因为它不做完整打包。\n2. 入口文件 main.ts&#x2F;jsvue2中是通过引入 vue 的构造函数来构造一个实例，然后通过实例来创建 Vue 应用。vue3中通过 import { createApp } from ‘vue’ 用这个工厂函数来创建 Vue 应用。\n3. 根节点差异vue3中可以没有根标签，但是vue2中必须写根标签。vue3 会将所有的节点放入一个隐形的 Fragment 容器中，这个 Fragment 容器会作为根节点。\n4. 写法上 setup 和 thisvue3 的 setup 函数必须返回出去，setup语法中可接收2个参数 setup(props,context)vue2中this.$attrs,this.$slots,this.$emit等同context中attrs，slots，emit在 vue2 中数据访问一般都是this.xxx。\n5. 指令和插槽\nvue2中使用slot可以直接使用slot,而vue3中必须使用v-slot的形式或者简写形式，作用域插槽的 slot-scope=&quot;xxx&quot; 也废弃了。\nv-for与v-if在vue2中优先级高的是v-for指令，而且不建议一起使用\nvue3中v-for与v-if,只会把当前v-if当做v-for中的一个判断语句，不会相互冲突\nvue3中移除keyCode作为v-on的修饰符，当然也不支持config.keyCodes\nvue3中移除v-on.native修饰符（表示监听原生事件）\nvue3中移除过滤器filter\n\n6. 响应式原理\nvue2的响应式原理用Object.defineProperty的get和set进行数据劫持，从而实现响应式\n  vue2中只有get和set方法去进行属性的读取和修改操作，当我们进行新增，删除时，页面不会实时更新  直接通过下标改数组，页面也不会实时更新\n\nvue3中响应式原理使用Proxy进行代理，使用window内置对象Reflect反射，学了Es6的语法的就知道我们在使用Proxy进行代理。\n  Proxy可以拦截对象中任意的属性变化，当然包括读写，添加，删除等  Reflect对源对象属性进行操作\n\n\n7. 生命周期可通过 v2 和 v3 的生命周期这两篇文章来感受他们的区别。\n8. 计算属性和监听器关于这部分整体上聚焦于 vue3 中的三个钩子方法：watch、watchEffect、computed\ncomputed主要是用法上，需要用组合式 api 的方式来引入并使用。vue2:\n    computed: &#123;        computedPropertyName: function () &#123;return ... &#125;        computedPropertyName: &#123; get: function () &#123;return ... &#125;, set: function (newValue) &#123;... &#125; &#125;&#125;\n\nvue3:\n// 简写 接收一个默认返回的函数const count = computed(() =&gt; &#123;    return state.someState + 1&#125;)// 可写const count = ref(1)const plusOne = computed(&#123;  get: () =&gt; count.value + 1,  set: (val) =&gt; &#123;    count.value = val - 1  &#125;&#125;)plusOne.value = 1console.log(count.value)\n\nwatchvue2:\nwatch: &#123;    watchPropertyName: function (newValue, oldValue) &#123;... &#125;    watchPropertyName: &#123; handler: function (newValue, oldValue) &#123;... &#125;, immediate: true,deep: true &#125;&#125;\n\nvue3:\nwatch(() =&gt; state.someState, (newValue, oldValue) =&gt; &#123;...&#125;)watch(() =&gt; state.someState, (newValue, oldValue) =&gt; &#123;...&#125;, &#123; immediate: true, deep: true &#125;)\n\n参数有四种类型：\n\nRef 对象（ref 创建的容器，如 count、userRef）；\nreactive 对象（reactive 创建的代理对象，如 names）；\n计算属性（computed 创建的函数）；\n依赖追踪函数（就是你写的箭头函数 () &#x3D;&gt; 响应式属性）—— 本质是让 Vue 执行这个函数，追踪函数内部访问的响应式属性。\n\n也有立即追踪和深度追踪的参数可传。\n\n注意点：在传入多个参数时会出现新旧值相同的情况，这时候就需要使用依赖追踪函数来传递了。依赖追踪函数这种方式也可以用来深度监听某个确切的属性。\n\nwatch([()=&gt;names.age,()=&gt;names.familyName],(newValue,oldValue)=&gt;&#123;  console.log(&#x27;names改变了&#x27;,newValue,oldValue)&#125;)\n\nwatchEffect这个是 vue3 中的新增的，用于监听一个函数，这个函数内部访问的响应式属性。作用是 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。相当于开启了 immediate: true 和 deep: true ，并且可以根据用的响应式变量自动进行追踪。简单来说，它就是让 watch 的语法更加简洁，但是会使依赖项不太明确。\nwatchEffect(() =&gt; &#123;&#125;)\n\n9. 全局 api 转移vue2 中全局 api 存放在 Vue 对象上，而 vue3 中全局 api 存放在 Vue 对象的 prototype 上。\n在使用时多从 Vue.XXX 成了 app.XXX\n","categories":["vue"],"tags":["vue"]},{"title":"vue2 基本语法","url":"/2025/10/18/vue-vue2%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","content":"vue 的语法介绍vue虽然是javascript的一套框架，但是他依然有许多特有的语法，还是需要掌握的。对于引入vue源码的方式不做探讨，在正式的开发中，不会通过这种方式。无论是下载到本地还是直接用cdn建议在学习的时候这样用，开发中不会如此使用。\nvue 指令\n内容渲染指令 v-text： 用于绑定文本内容，当数据发生变化时，文本内容也会跟着改变，v-text 指令会覆盖元素内默认的值。 v-html： 用于绑定 HTML 内容，当数据发生变化时，HTML 内容也会跟着改变。使用此指令要注意安全，防止 XSS 攻击。 v-pre： 跳过当前节点的编译过程，将内容原封不动的插入到页面中。  ： 插值表达式，用于在模板中插入变量或者js表达式的值。可将内容渲染到指定位置，也不会覆盖元素里的默认值。\n\n条件判断指令 v-if： 基于条件判断创建或者移除元素节点。 v-show： 基于条件控制元素的 display:none 样式属性。 v-else&#x2F;v-else-if： 与v-if一起使用，辅助v-if进行判断渲染。需要紧接v-if指令。\n\n事件绑定指令 **v-on:**： 用于绑定事件监听，可以简写为 @ 。\n\n属性绑定指令 **v-bind:**： 可以动态设置 html 或者 vue 的标签属性。可以简写为 : 。\n\n循环指令 v-for： 列表渲染指令，用来基于一个数组来循环渲染一个列表结构。 v-for=&quot;(item, index) in list&quot; 使用该指令时最好加上 key 属性，以便于 diff 算法正常运行。\n\n表单双向绑定指令 v-model： 要注意的是，v-model 指令只能用于表单元素。 作用： 1、数据变化 &#x3D;&gt; 视图自动更新 2、视图变化 &#x3D;&gt; 数据自动更新 可绑定的元素示例：     文本框  input:text &#x3D;&gt; value     文本域 textarea &#x3D;&gt; value     复选框 input:checkbox &#x3D;&gt; checked     单选框 input:radio &#x3D;&gt; checked     下拉菜单 select &#x3D;&gt; value\n\n插槽指令 **v-slot:**： 插槽指令，用于定义组件的模板。它是父组件使用的来填充子组件的语法，可以简写为  #.\n\n与css结合的功能性指令 v-cloak：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。\n [v-cloak] &#123;display: none;&#125;\n\n指令修饰符\n\n\n\n针对于事件绑定 v-on\n\nVue 事件修饰符\n\n\n\n修饰符\n作用\n示例\n\n\n\n.stop\n阻止事件冒泡（等价于 event.stopPropagation()）\n&lt;button @click.stop=&quot;handleClick&quot;&gt;点击&lt;/button&gt;\n\n\n.prevent\n阻止默认行为（等价于 event.preventDefault()，如表单提交、链接跳转）\n&lt;form @submit.prevent=&quot;handleSubmit&quot;&gt;提交&lt;/form&gt;\n\n\n.capture\n事件捕获模式（从父元素到子元素触发）\n&lt;div @click.capture=&quot;handleParent&quot;&gt;父元素&lt;/div&gt;\n\n\n.self\n仅当事件触发在当前元素本身（非子元素）时执行\n&lt;div @click.self=&quot;handleSelf&quot;&gt;点击自身才触发&lt;/div&gt;\n\n\n.once\n事件仅触发一次（触发后自动解绑）\n&lt;button @click.once=&quot;handleOnce&quot;&gt;仅触发一次&lt;/button&gt;\n\n\n.passive\n标记事件为”被动”（不调用 preventDefault()），优化滚动性能（如 touchmove）\n&lt;div @touchmove.passive=&quot;handleScroll&quot;&gt;滚动&lt;/div&gt;\n\n\n.native\n监听组件根元素的原生事件（用于自定义组件），vue3中已经移除\n&lt;MyComponent @click.native=&quot;handleNative&quot;&gt;原生点击&lt;/MyComponent&gt;\n\n\n\nVue 按键修饰符\n\n\n\n修饰符\n对应按键\n示例\n\n\n\n.enter\n回车键\n&lt;input @keyup.enter=&quot;handleEnter&quot;&gt;回车触发&lt;/input&gt;\n\n\n.tab\nTab键\n&lt;input @keyup.tab=&quot;handleTab&quot;&gt;Tab触发&lt;/input&gt;\n\n\n.delete\n删除&#x2F;退格键\n&lt;input @keyup.delete=&quot;handleDelete&quot;&gt;删除触发&lt;/input&gt;\n\n\n.esc\nEsc键\n&lt;input @keyup.esc=&quot;handleEsc&quot;&gt;Esc触发&lt;/input&gt;\n\n\n.space\n空格键\n&lt;input @keyup.space=&quot;handleSpace&quot;&gt;空格触发&lt;/input&gt;\n\n\n.up\n上箭头键\n&lt;input @keyup.up=&quot;handleUp&quot;&gt;上键触发&lt;/input&gt;\n\n\n.down\n下箭头键\n&lt;input @keyup.down=&quot;handleDown&quot;&gt;下键触发&lt;/input&gt;\n\n\n.left\n左箭头键\n&lt;input @keyup.left=&quot;handleLeft&quot;&gt;左键触发&lt;/input&gt;\n\n\n.right\n右箭头键\n&lt;input @keyup.right=&quot;handleRight&quot;&gt;右键触发&lt;/input&gt;\n\n\n\nVue 系统修饰符\n\n\n\n修饰符\n对应按键\n示例\n\n\n\n.ctrl\nCtrl键\n&lt;input @keydown.ctrl.s=&quot;handleSave&quot;&gt;Ctrl+S 触发&lt;/input&gt;\n\n\n.alt\nAlt键\n&lt;input @keydown.alt.s=&quot;handleAltSave&quot;&gt;Alt+S 触发&lt;/input&gt;\n\n\n.shift\nShift键\n&lt;input @keydown.shift.s=&quot;handleShiftSave&quot;&gt;Shift+S 触发&lt;/input&gt;\n\n\n.meta\nWindows键&#x2F;Command键\n&lt;input @keydown.meta.s=&quot;handleMetaSave&quot;&gt;Win/Cmd+S 触发&lt;/input&gt;\n\n\n.exact\n精确匹配系统修饰符（仅按下指定修饰符时触发，不允许额外按键）\n&lt;button @click.ctrl.exact=&quot;handleCtrl&quot;&gt;仅 Ctrl+点击&lt;/button&gt;\n\n\n\nVue 鼠标按钮修饰符\n\n\n\n修饰符\n对应鼠标按键\n示例\n\n\n\n.left\n鼠标左键\n&lt;div @mousedown.left=&quot;handleLeftClick&quot;&gt;左键点击&lt;/div&gt;\n\n\n.right\n鼠标右键\n&lt;div @mousedown.right=&quot;handleRightClick&quot;&gt;右键点击&lt;/div&gt;\n\n\n.middle\n鼠标中键\n&lt;div @mousedown.middle=&quot;handleMiddleClick&quot;&gt;中键点击&lt;/div&gt;\n\n\n\n\n  这些修饰符可以组合使用，例如 @click.ctrl.shift=&quot;handleClick&quot; 表示同时按下Ctrl和Shift键时点击才触发。\n\n针对于属性绑定 v-model\n\n.lazy 从 “输入时同步” 改为 “失去焦点 &#x2F; 回车时同步”（减少数据更新频率）&lt;input v-model.lazy=&quot;username&quot;&gt;\n.number 将输入值自动转为 Number 类型（若输入非数字则保留字符串） &lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;\n.trim 自动去除输入值两端的空格（避免用户误输入空格） &lt;input v-model.trim=&quot;password&quot;&gt;\n\n\n针对于属性绑定 v-bind\n\n.prop 指定绑定的属性名称，如 v-bind:value=&quot;username&quot; =&gt; v-bind.prop:value=&quot;username&quot;\n.camel 将属性名称转换为驼峰命名法（如 data-username &#x3D;&gt; dataUsername） &lt;div v-bind.camel:data-username=&quot;username&quot;&gt;\n.sync 创建一个 bidirectional 绑定，即 v-model 的语法糖，用于组件之间传递数据 &lt;child-component v-model=&quot;username&quot;&gt;&lt;/child-component&gt;vue3中已经移除\n\n\n\n\n!!!注意: 关于简写指令，一共有三个，建议使用直接简写，但是如果没有用简写，就这三个都尽量不要用简写，保持一致，这是一个规范问题并非语法限制。\n\ncomputed计算属性computed 语法    computed: &#123;        computedPropertyName: function () &#123;return ... &#125;        computedPropertyName: &#123; get: function () &#123;return ... &#125;, set: function (newValue) &#123;... &#125; &#125;&#125;\n\n默认写法只能读取不能修改，如需修改，则需要使用setter方法，也就是第二种方式，写完整。\n计算属性的特点\ncomputed属性的计算结果会被缓存，只有当依赖的属性值发生变化时才会重新计算。在遇到一些计算复杂的属性时，可以用计算属性来优化性能。\ncomputed属性的计算结果会自动添加到Vue实例的响应式系统中，所以当计算属性依赖的属性值发生变化时，计算属性也会自动更新。\ncomputed属性可以包含多个计算属性，多个计算属性之间可以相互依赖。\ncomputed 在v2中也是与 data 同级的属性。\n\nwatch侦听器watch 语法watch: &#123;    watchPropertyName: function (newValue, oldValue) &#123;... &#125;    watchPropertyName: &#123; handler: function (newValue, oldValue) &#123;... &#125;, immediate: true,deep: true &#125;&#125;\n\nwatch 侦听器的特点\n只能侦听响应式属性，不能侦听普通属性,也就是 data 属性中声明的属性。\nimmediate: 立即执行，是否在初始化时执行一次监听函数,默认为 false。 deep: 是否深度监听,也就是针对对象嵌套属性进行深层监听，默认为 false。\n\nv2的生命周期可见另外独立文章介绍。\nv2的一些常用选项vue2的整体语法是基于选项式api的。\nelel 是一个字符串，用于指定组件的挂载点，即在页面中指定的元素。只在 new Vue() 实例时才有效。也就是一般都是挂到 root&#x2F;app 上,由于 el 是替换原来的 dom 节点，因此一般不直接挂在 html&#x2F;body 上。如官网给出的示例。\nnew Vue(&#123;    el: &#x27;#app&#x27;&#125;)\n\nname为组件指定一个名称，用于组件的注册和引用。\ndatadata 是一个对象，用于定义组件的初始数据。data 可以是一个函数，返回一个对象，也可以是一个对象。data就是声明组件的响应式数据。在单文件组件中，data 必须是一个函数，以避免数据来源混乱。\npropsprops 可以是数组或对象，用于接收来自父组件的数据。\n// 简单语法Vue.component(&#x27;props-demo-simple&#x27;, &#123;  props: [&#x27;size&#x27;, &#x27;myMessage&#x27;]&#125;)// 对象语法，提供验证Vue.component(&#x27;props-demo-advanced&#x27;, &#123;  props: &#123;    // 检测类型    height: Number,    // 检测类型 + 其他验证    age: &#123;      type: Number,      default: 0,      required: true,      validator: function (value) &#123;        return value &gt;= 0      &#125;    &#125;  &#125;&#125;)\n\nmethodsmethods 是一个对象，用于定义组件的方法。在这个选项中，方法中的 this 指向组件实例。常用来处理一下组件的逻辑或者数据。\n其他选项有上面出现过的 computed、watch、还有那些生命周期的钩子函数均是选项。！v2api参考\n插槽另见独立行文，将 vue2 和 vue3 联合一并介绍了。\n组件通信组件通信是 vue 中非常关键的知识点，独立成文。\nvue2 中的 this 的使用v2中几乎所有的数据和方法都是通过 this 来访问的，this 的作用域是当前组件实例，因此 this 可以访问当前组件实例的所有数据、方法、属性。要访问组件资源或者访问 vue 内置的 api 都要用 this.\n","categories":["vue"],"tags":["vue"]},{"title":"vue2 生命周期","url":"/2025/10/22/vue-vue2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"v2 的生命周期v2生命周期图示！v2生命周期图示\n生命周期介绍一、创建阶段\nbeforeCreate  实例刚初始化，数据观测和生命周期函数未配置，无法访问 data 和 methods。\n\ncreated  实例创建完成，数据观测和方法已配置，可访问 data 和 methods，但 未挂载 DOM。常用于初始化数据、异步请求等。\n\n\n二、挂载阶段\nbeforeMount  模板编译完成，即将挂载 DOM，但页面未渲染（虚拟 DOM 已生成）。\n\nmounted  实例已挂载到 DOM，可操作真实 DOM，常用于初始化第三方插件、绑定事件等。\n\n\n三、更新阶段\nbeforeUpdate  数据更新前触发，虚拟 DOM 未重新渲染，可获取更新前的状态。\n\nupdated  数据更新且 虚拟 DOM 重新渲染完成，页面已更新，避免在此阶段修改数据（可能触发死循环）。\n\n\n四、卸载阶段\nbeforeUnmount  实例即将卸载，可用于清理定时器、解绑事件等准备工作。\n\nunmounted  实例已卸载，所有子组件也被销毁，清理操作在此完成（如移除监听、销毁实例引用）。\n\n\n\n!!!注意: 这些生命周期钩子函数也都是 v2 的一个属性，使用时也是与 data 属性同级，将逻辑写到对应的属性中。\n\n","categories":["vue"],"tags":["vue"]},{"title":"vue 响应式数据声明","url":"/2025/11/08/vue-vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A3%B0%E6%98%8E/","content":"vue3 响应式数据声明前景介绍由于在组合式函数中没有了 data 因此我们需要使用一些方法来声明响应式数据。\n有关响应式数据的方法1. ref这个方法是最常用的、最通用的方法来声明响应式的数据。ref 是 Vue 3 最灵活的响应式 API，支持所有数据类型（基本类型、对象、数组），本质是通过 Object.defineProperty 包装了一个“响应式容器”，脚本中需通过 .value 操作，模板中会自动解包（无需 .value）。\n2. reactivereactive 仅支持引用类型（对象 &#x2F; 数组），直接对原始对象进行 Proxy 代理，脚本中无需 .value，直接操作属性即可，且默认是深度响应式（嵌套对象也会被代理）。当然 ref 在代理引用类型时，正是基于 reactive 的。\n3. shallowRef 和 shallowReactive这两个是为了性能优化而提供的。默认 ref/reactive 是深度响应式（嵌套对象 &#x2F; 数组都会被代理），若数据结构庞大（如大表单、树形数据）或无需深层响应，用浅层 API 可提升性能（避免不必要的代理）。\n4. toRefsreactive 创建的响应式对象，直接解构会丢失响应式（得到原始值）。toRefs 可将其转为 Ref 对象集合，解构后仍保持响应式（需 .value 操作）。看着很高大上，实际上就是把里面的属性都转化为 Ref 对象。也就是用 ref 包裹了一遍。\n对于数组&#x2F;对象的 ref 对象，直接解构其 value 也不会破坏响应式。\n5. toReftoRef 针对响应式对象的单个属性创建 Ref 引用，修改该引用会同步到原对象，且即使属性不存在，也会创建一个 “空引用”（不会报错）。这个其实很扯，就是相当于把一个变量值（地址值可能更贴切）给到两个变量名。\n6. toRaw获取响应式对象的原始（非代理）对象。\n\nreactive 直接创建的对象 &#x2F; 数组（必生效）；\nref 包装的 对象 &#x2F; 数组（需先通过 .value 拿到内部代理对象，再用 toRaw）；\n对 ref 包装的 基本类型（number&#x2F;string&#x2F;boolean）无效（因为基本类型是通过容器 .value 实现响应式，没有 “原始对象” 可拿）。\n\n它的作用在于修改原始对象不会触发视图更新。\n7. readonly&#x2F;shallowReadonly创建一个只读的响应式对象。若需要 “响应式但不可修改” 的数据（如组件常量、父组件传递的不可变数据），可用 readonly（深度只读）或 shallowReadonly（表层只读）。表层和深层指的是最外层的属性和嵌套属性。\n响应式数据判断\nisRef: 检查值是否为一个 ref 对象。\nisReactive：检查对象是否是由 reactive 创建的响应式代理。\nisReadonly: 检查对象是否是由 readonly 创建的只读代理。\nisProxy：检查对象是否是由 reactive 或 readonly 创建的 proxy。\n\n","categories":["vue"],"tags":["vue"]},{"title":"vue3 生命周期","url":"/2025/10/25/vue-vue3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"vue3 的生命周期vue3 的生命周期图示\nvue3 的生命周期介绍可以直接拿vue2的生命周期来类比进行。将 vue2 中 beforeDestroy/destroyed 改为了 beforeUnmount/unmounted 语义更加明确了。\n生命周期对应的组合式钩子函数\nbeforeCreate&#x3D;&#x3D;&#x3D;&gt;Not needed*\ncreated&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;Not needed*\nbeforeMount &#x3D;&#x3D;&#x3D;&gt;onBeforeMount\nmounted&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onMounted\nbeforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdate\nupdated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUpdatedupdated\nbeforeUnmount &#x3D;&#x3D;&gt;onBeforeUnmount\nunmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUnmounted\n\n前两个生命周期钩子被涵盖在 setup 执行时机里了，直接写在顶层函数里即可。但是 setup 执行的要比这两个生命周期钩子先执行，所以 setup 函数里不能直接使用 this。\n","categories":["vue"],"tags":["vue"]},{"title":"vue 介绍","url":"/2025/10/15/vue-vue%E4%BB%8B%E7%BB%8D/","content":"vue 介绍相关背景\nvue是一款渐进式的javascript 框架.\nvue 是一个用于构建用户界面的 JavaScript 框架，它基于 MVVM 模式，将数据与视图进行分离，并使用虚拟 DOM 来提高性能。是由尤雨溪于 2014 年 10 月 27 日开源的前端框架，经过多年的发展，它已经成为前端广泛使用并且非常流行的框架之一。\nvue3 是 vue 官方的更新版本，在 vue2 的基础上进行了大量优化，包括了 TypeScript 的支持、新的 Composition API、更好的性能优化等。随着vue3的发展，目前vue2已经停止更新，推荐使用vue3。而vue3的组合式API也使得开发更加优雅，更加方便。\nv2 文档地址：v2地址\nv3 文档地址：v3地址\n\nvue 的核心概念\nmvvm模式 是 vue 的核心概念，mvvm 模式是一种软件架构模式，它将数据（Model）与视图（View）进行分离，并使用一个中间层（ViewModel）来连接两者。在vue中的实际体现就是当你修改数据的时候，视图会自动更新，反之亦然。\n单文件组件：vue 的核心概念，单文件组件是一个 .vue 文件，它包含模板、脚本和样式，这些内容都以一种特殊的格式组织在一起，并最终被编译成 JavaScript 代码。单文件组件使得开发更加方便，因为你可以在一个文件中定义数据和视图，并使用 JavaScript 来处理数据。\n\n","categories":["vue"],"tags":["vue"]},{"title":"vue 插槽","url":"/2025/10/29/vue-vue%E6%8F%92%E6%A7%BD/","content":"vue插槽前景介绍你真的学懂插槽了吗？由于 vue2 和 vue3 中插槽语法整体上变化不算太大，插槽也可作为独立的知识，因此不仿并写 vue2 和 vue3 的插槽，并且独立成文。\n插槽的声明语法尽管插槽分三种，但是声明插槽的语法只有一种，且在 vue2 和 vue3 中一致。插槽声明一般是在子组件的模板中定义的。\n&lt;template&gt;  &lt;div&gt;    // 默认插槽    &lt;slot&gt;&lt;/slot&gt;    // 具名插槽    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;\n\n插槽的引用语法1. 默认插槽默认插槽一般用于组件的根元素，即组件的模板。插槽的定义只能用一个 &lt;slot&gt; 元素定义。在组件包裹的里面的内容会替换掉默认的内容。如果没有包裹东西就会显示默认的内容。也就是说如果使用默认插槽不能使用自闭合的标签。\n// 父组件&lt;MyComponent&gt;  「&lt;p&gt;这是默认插槽的内容&lt;/p&gt;」&lt;/MyComponent&gt;// 子组件&lt;template&gt;  &lt;div&gt;    &lt;slot&gt; 「&lt;p&gt;这是子组件的默认插槽内容&lt;/p&gt;」&lt;/slot&gt;  &lt;/div&gt;\n\n2. 具名插槽具名插槽和默认插槽引用类似，但是可以有多个，并且有 name 属性来区分。v-solt 也等价与 #，也就是简写形式。在 vue2 中可以用 slot=&#39;footer&#39; 属性来指定插槽名称。等价于 v-slot:footer 和 #footer。vue3 中移除了 slot 属性.\n// 父组件&lt;MyComponent&gt;  &lt;template v-slot:footer&gt;    &lt;p&gt;这是具名插槽的内容&lt;/p&gt;  &lt;/template&gt;&lt;/MyComponent&gt;// 子组件&lt;template&gt;  &lt;div&gt;    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;\n\n3. 作用域插槽作用域插槽的用法和具名插槽类似,也可以不命名如默认插槽一样，但是它的主要作用是用来传递数据。接收数据时有一个等号，他是自定义的数据收集起来的名。vue2中 slot-scope=&quot;props&quot; 来接收数据，在 vue3中 slot-scope=&quot;props&quot; 已经被废弃。统一了插槽使用方法。\n// 父组件&lt;MyComponent&gt;  &lt;template v-slot:default=&quot;scope&quot;&gt;    &lt;p&gt;&#123;&#123; scope.name &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; scope.age &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; scope.sex &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; scope.address &#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123; scope.phone &#125;&#125;&lt;/p&gt;  &lt;/template&gt;&lt;/MyComponent&gt;// 子组件&lt;template&gt;  &lt;div&gt;    &lt;slot :name=&quot;name&quot; :age=&quot;age&quot; :sex=&quot;sex&quot; :address=&quot;address&quot; :phone=&quot;phone&quot;&gt; &lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;\n\n总结\n要注意插槽的三种方法只用于父组件中，不能用于子组件中。子组件中只能使用 slot 标签，来定义插槽。\n作用域插槽实际上它的作用就是将子组件的数据传递给父组件。\n插槽的 name 属性，可以自定义，也可以不写，默认为 default。\n\n","categories":["vue"],"tags":["vue"]},{"title":"vue 组件通信","url":"/2025/11/05/vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","content":"vue 组件通信前景介绍组件通信是保证 vue 数据流的关键，也有很多方式可以实现组件通信。当然，也有一些很少用到的方式，就不多介绍了，可以自行寻找其他文章了解查看。另外像通过 vuex 这种状态插件实现 和 vue router 路由传值，就不在本文中阐述了。\n组件通信方式1. props 和 自定义事件（emit）实现父子组件传值父子组件传值，最简单的方式就是通过 props 传值给子组件，然后通过 emit 触发事件，将子组件的数据传递给父组件。这种方式也是正常在使用 vue 这个框架的时候最常用的一种方式。这个过程中其实包含了两块，父传子，子传父。\n在 vue2 中：\n// 父组件&lt;child-component :message=&quot;parentMessage&quot; @update=&quot;handleUpdate&quot; /&gt;// 子组件export default &#123;  props: [&#x27;message&#x27;],  methods: &#123;    sendToParent() &#123;      this.$emit(&#x27;update&#x27;, newValue)    &#125;  &#125;&#125;\n\nthis.$emit 可以触发父组件的事件，第二个参数为传递的数据，在这个例子中，handleUpdate 是父组件定义的处理函数，它的入参就是这里传递的 newValue。\n在 vue3 中：\n&lt;!-- 父组件 --&gt;&lt;child-component  :message=&quot;parentMessage&quot;  @update=&quot;handleUpdate&quot;/&gt;&lt;!-- 子组件 --&gt;&lt;script setup&gt;// 方式1：选项式声明defineProps([&#x27;message&#x27;])defineEmits([&#x27;update&#x27;])// 方式2：完整语法const props = defineProps(&#123;  message: String&#125;)const emit = defineEmits(&#123;  update: (value) =&gt; &#123;    // 可添加验证    return typeof value === &#x27;string&#x27;  &#125;&#125;)const sendToParent = () =&gt; &#123;  emit(&#x27;update&#x27;, newValue)&#125;&lt;/script&gt;\n\n在 vue3 中，依赖于组合式的 api 函数 defineProps 和 defineEmits\n2.  Provide &#x2F; Inject 依赖注入模式用于祖先组件和后代组件，避免了使用第一种方式层层透穿。祖先传递给后代组件。在 vue2 中：\n// 祖先组件export default &#123;  provide() &#123;    return &#123;      theme: this.themeColor,      user: this.userInfo    &#125;  &#125;&#125;// 后代组件export default &#123;  inject: [&#x27;theme&#x27;, &#x27;user&#x27;]&#125;\n\n在 vue3 中：\n&lt;!-- 祖先组件 --&gt;&lt;script setup&gt;import &#123; provide, ref, reactive &#125; from &#x27;vue&#x27;const themeColor = ref(&#x27;dark&#x27;)const userInfo = reactive(&#123; name: &#x27;John&#x27; &#125;)// 提供响应式数据provide(&#x27;theme&#x27;, themeColor)provide(&#x27;user&#x27;, userInfo)&lt;/script&gt;&lt;!-- 后代组件 --&gt;&lt;script setup&gt;import &#123; inject &#125; from &#x27;vue&#x27;const theme = inject(&#x27;theme&#x27;)const user = inject(&#x27;user&#x27;, defaultValue) // 可提供默认值&lt;/script&gt;\n\n3. 模板引用 refvue2:\n&lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;child-component ref=&quot;child&quot; /&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  mounted() &#123;    this.$refs.child.childMethod()  &#125;&#125;&lt;/script&gt;\n\nvue3:\n&lt;!-- 父组件 --&gt;&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;const child = ref(null)onMounted(() =&gt; &#123;  child.value.childMethod()&#125;)&lt;/script&gt;&lt;template&gt;  &lt;child-component ref=&quot;child&quot; /&gt;&lt;/template&gt;\n\n这种方式虽然看着并不麻烦，但是在实际开发中应该尽可能避免使用，因为这种方式相当于直接访问了 dom ，会破坏 vue 框架的设计，当然也会有一定的性能损失。\n4. 使用作用域插槽作用域插槽也是子组件将数据传递给父组件的一种方式，具体用法可见独立行文，vue插槽。\n5. 事件总线虽然讲到组件通信就离不开事件总线，但是根据我在实际项目中的感受，几乎没有事件总线使用的场景。他会导致项目难以维护，数据流混乱，因此大部分时候都用一些状态插件管理。\nvue2:\n// 创建事件总线 在独立的 bus.js 文件中，当使用时也需要在组件引入这个 vue 实例export const eventBus = new Vue()// 组件A - 发送事件eventBus.$emit(&#x27;message&#x27;, data)// 组件B - 接收事件eventBus.$on(&#x27;message&#x27;, (data) =&gt; &#123;  // 处理数据&#125;)// 组件B - 移除监听eventBus.$off(&#x27;message&#x27;)\n\nvue3:\n// 使用 mitt 或自定义事件发射器import mitt from &#x27;mitt&#x27;export const emitter = mitt()// 发送事件emitter.emit(&#x27;message&#x27;, data)// 监听事件emitter.on(&#x27;message&#x27;, (data) =&gt; &#123;  // 处理数据&#125;)// 移除监听emitter.off(&#x27;message&#x27;)\n\n在vue3中，那三个原生的方法 $on $off $emit 都被弃用，可用的是 mitt 这个库来模拟事件总线。也就是说 vue3 中原生根本不支持事件总线。\n","categories":["vue"],"tags":["vue"]},{"title":"前端包管理器","url":"/2025/09/19/web%E5%B7%A5%E7%A8%8B%E5%8C%96-%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/","content":"包管理器对于前端开发而言，包管理是其中非常重要的一环。\nnpmnpm作为node包管理器，是nodejs官方的包管理工具。尽管它解决的代码共享的问题，在那个年代是极为特殊的思想，但是它依旧有很多的问题存在。而其他几个包管理工具，或多或少都解决了这些问题。安装慢、node_modules 过大、依赖库版本锁定不一致 等等的问题。\nyarnyarn的出现纯粹是为了解决npm的这些问题。在那个 npm install 慢、依赖版本时常出错的年代，Yarn 就像是完成了一次大的技术升级，把整个包管理的流程都做了优化。\n\nyarn.lock 文件：引入了自己的锁文件（区别于 npm 的 package-lock.json），更早解决了依赖版本不一致的问题\n更快的安装体验：Yarn 通过缓存机制和并行安装方式，大大提升了安装速度。装过一次的包，下次无需重新拉。\n离线安装：这是一个非常实用的特性，即使断网，你也可以依赖缓存离线安装项目，适合对网络依赖敏感的开发场景。\n原子化安装：安装失败会自动回滚，防止项目进入“半安装”状态。\n\npnpmpnpm 的初衷是解决占用磁盘空间过大问题。pnpm 通过一种“硬链接 + 内容寻址”的存储方式，将所有依赖包统一下载到全局缓存中（.pnpm-store），每个项目的 node_modules 并不真的“安装”包，而是使用软链接指向缓存中的真实文件，同一个包只会下载、存储一份，再多个项目共用。这样就带来了巨多好处，比如：下载速度飞快，空间占用大幅度下降，并且还可以完美兼容现有生态（保留 node_modules）。并且，针对 Monorepo 架构，pnpm 也提供了非常好的支持（应该可以说是支持最好的包管理器了）\ncnpmcnpm 是淘宝团队基于 npm 封装的包管理工具，cnpm 默认使用淘宝镜像，速度比 npm 快很多。但是在我看来，cnpm有许多的问题，我不建议大家使用。\n常用命令\n\n\n功能\nNPM 命令\nYarn 命令\nPNPM 命令\n\n\n\n安装依赖\nnpm install\nyarn install\npnpm install\n\n\n安装特定包\nnpm install\nyarn add\npnpm add\n\n\n移除包\nnpm uninstall\nyarn remove\npnpm remove\n\n\n更新包\nnpm update\nyarn upgrade\npnpm update\n\n\n初始化项目\nnpm init\nyarn init\npnpm init\n\n\n","categories":["web工程化"],"tags":["web工程化"]},{"title":"前端模块化规范","url":"/2025/09/16/web%E5%B7%A5%E7%A8%8B%E5%8C%96-%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/","content":"前端模块化规范什么是模块化?模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元.\n编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块，是将不同功能的函数封装起来，并提供使用接口，他们彼此之间互不影响，想要什么功能，就加载什么模块，可以实现按需加载。\n简单来说，模块化就是把系统分割成独立的功能块,提高代码的复用性。\n模块化开发的意义优点\n便于多人协作开发，每个部分开发不会干扰其它地方 ,降低了耦合性\n便于调试修改，因为模块独立，发现问题比较容易，修改一处，也不影响别处，利于前端性能优化.  \n利于代码复用，小块的代码可以更方便拿到别的项目中不加或者稍加修改使用，提高可维护性.\n便于功能的扩充，因为软件各个部分是独立的，不需要理解整个软件就可以添加功能,适合二次开发.\n解决了部分恼人的命名冲突以及烦琐的文件依赖.\n\n缺点1.系统分层，调用链会很长  2.模块间通信,模块间发送消息会很耗性能\n模块化的意义在于最大化的设计重用，以最少的模块、零部件，更快速的满足更多的个性化需求。\n模块化开发的一些规范1. CommonJS这个规范是node的规范,在此之后前端的模块化发展迅速.许多的主流前端框架都是都是由node基于搭建\n使用require导入内置的包或者导入自己写的文件,导入本地的包时记得用./表示文件路径,核心模块不需要\nCommonJS规范（运行时）1、每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。2、在模块中使用global 定义全局变量，不需要导出，在别的文件中可以访问到。3、每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。4、通过 require加载模块，读取并执行一个js文件，然后返回该模块的exports对象。5、所有代码都运行在模块作用域，不会污染全局作用域。6、模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。7、模块加载的顺序，按照其在代码中出现的顺序。\n2. ESM（编译时）在 ES Module 中用 export 用来导出模块，import 用来导入模块。CommonJS 模块同步加载并执行模块文件，ESM 模块提前加载并执行模块文件，ESM模块在预处理阶段分析模块依赖，在执行阶段执行模块，两个阶段都采用深度优先遍历.其实就是客户端的导出规范.\nCommonJS 输出的是一个值的拷贝；ES Modules 生成一个引用，等到真的需要用到时，再到模块里面去取值，模块里面的变量，绑定其所在的模块。以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\nnode中使用这种导入模式需要把后缀改为mjs\nESM导入规则 1.导入变量名\nimport greet from &#39;./greeting.js&#39;;\n 2.解构导出\nimport &#123; add, subtract &#125; from &#39;./math.js&#39;;\n 3.全部导出\nimport * as math from &#39;./math.js&#39;;\n3. AMD规范（requirejs）AMD的核心是预加载，先对依赖的全部文件进行加载，加载完了再进行处理。  适合在浏览器环境中异步加载模块。可以并行加载多个模块。 并可以按需加载。核心就是前端的require.js包的学习.\n使用    &lt;script data-main=&quot;js/main&quot; src=&quot;js/require.js&quot;&gt;&lt;/script&gt;    src引入requirejs，date-main将main模块为主模块加载\n官方网址: https://requirejs.org\n4. CMD规范（seajs）即通用模块定义。按需加载。在 CMD 规范中，一个模块就是一个文件，使用define来进行模块，define是一个全局函数。  factory 可以是一个函数，也可以是一个对象或字符串。\n唯一的问题：浏览器端不支持CommonJS规范淘宝“玉伯”仿照CommonJS规范，研发了一款插件 sea.js ，旨在把CommonJS规范搬到浏览器端运行「这种模块思想被称之为CMD」\n使用 (CMD)define(&#123;&#x27;website&#x27;:&#x27;oecom&#x27;&#125;);define(&#x27;这里是OECOM&#x27;);define(function(require,exports,module)&#123;&#125;)\n\nrequire参数也是一个方法，接收的参数为模块标识，其实就是需要加载模块的相对路径，作用就是加载其他模块。define(function(require,exports,module)&#123;    var a = require(&#x27;./a&#x27;);    //假设模块a有out方法。    a.out();&#125;)直接使用require加载属于是同步加载，require提供了async方法来在模块内部进行也不加载模块，并在加载完成以后执行指定的回调函数。define(function(require,exports,module)&#123;    require.async(&#x27;./a&#x27;,function(a)&#123;        a.doSomething()        &#125;)        require.async([&#x27;./c&#x27;,&#x27;./b&#x27;],function(c,b)&#123;        c.doSomething()        b.doSomething()        &#125;)    &#125;require 是同步往下执行，require.async 则是异步回调执行。require.async 一般用来加载可延迟异步加载的模块。exports是一个用来想外接提供模块接口的对象define(function(require,exports)&#123;    var name = 10;    exports.name = name;    exports.out = function()&#123;        console.log(&quot;输出内容&quot;)    &#125;    &#125;)    当然导出模块还可以直接使用return的方式define(function(require)&#123;    return&#123;        name:10,        out:function()&#123;            console.log(&quot;输出内容&quot;)        &#125;    &#125;&#125;)\n","categories":["web工程化"],"tags":["web工程化"]},{"title":"css BEM 规范","url":"/2025/08/15/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83-css%20BEM%20%E8%A7%84%E8%8C%83/","content":"CSS BEM 规范详解BEM（Block, Element, Modifier）是一种结构化的 CSS 命名方法，由 Yandex 团队提出，用于创建可复用、可维护的前端组件。核心思想是将 UI 拆分为独立的块，通过清晰的命名规则建立层级关系。\nBEM 核心概念1. Block（块）\n定义：页面中独立的、有意义的组件（如 header, card, menu）。\n命名：使用单个单词或连字符连接（如 user-card, search-form）。\n\n2. Element（元素）\n定义：块的组成部分，不能独立于块存在（如 navbar__link, card__title）。\n命名：使用双下划线 __ 连接块名和元素名（如 block__element）。\n\n3. Modifier（修饰符）\n定义：改变块或元素的外观、状态或行为（如 button--primary, card--disabled）。\n命名：使用双连字符 -- 连接（如 block--modifier 或 block__element--modifier）。\n\nBEM 命名规则\n使用连字符 - 分隔单词（如 user-card）。\n元素用双下划线 __ 连接块（如 user-card__avatar）。\n修饰符用双连字符 -- 连接（如 user-card--highlighted）。\n避免嵌套元素超过两层（如 block__elem1__elem2 不推荐）。\n\n","categories":["代码规范"],"tags":["代码规范"]},{"title":"git 提交和分支管理 规范","url":"/2025/10/04/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83-git%E6%8F%90%E4%BA%A4%E5%92%8C%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/","content":"git 提交和分支管理 规范git 提交规范 –&gt; Git Commit Message Conventions\n提交信息格式：&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\ntype 类型（必填）：描述提交的类别\n\nfeat：新功能（如 feat: add user login functionality）\n\nfix：修复 bug（如 fix: correct login timeout issue）\n\nrefactor：重构代码（不影响功能的改动）\n\ndocs：修改文档\n\nstyle：格式（代码样式修改，不影响代码逻辑）\n\ntest：增加测试\n\nchore：构建过程或辅助工具的变动\n\nscope: 本次提交影响的范围，标识变动涉及的模块或功能\n\nsubject： 提交说明（必填）：简洁说明本次变动，建议 50 字符以内\n\n\ngit分支管理规范\n功能分支命名应遵循 类型/功能 格式，常见类型包括：\n\nfeat/：新功能开发（如 feat/user-management）\nfix/：bug 修复（如 fix/login-bug）\nrefactor/：代码重构（如 refactor/auth-service）\nchore/：项目构建或工具变动（如 chore/update-dependencies）\ndocs/：文档修改（如 docs/update-readme）\nhotfix/：紧急修复（如 hotfix/critical-bug）\n\n\n功能分支应从 develop 分支创建，并在开发完成后合并回 develop 分支。围绕 develop 分支进行开发，以保持代码库的稳定性。\n\n当功能分支开发完成后，应删除该分支，以保持代码库的整洁。\n\n\n","categories":["代码规范"],"tags":["代码规范"]},{"title":"git 基础命令","url":"/2025/08/05/%E5%B7%A5%E5%85%B7-git-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","content":"git 基础命令1. 配置不加尖括号内的东西可以查看相关配置。\n**git config [–global] user.name &lt;”your-name”&gt; :**设置名字\ngit config [–global] user.email &lt;”your-email”&gt; : 设置邮箱\n2. 启动\ngit init [project-name]: 创建或者（不加参数时）在当前目录初始化一个git代码库。\ngit clone url: 下载一个项目和它的整个代码历史。\n\n3. 日常操作\ngit init: 初始化仓库，默认 master .\n**git add .:**提交所有文件修改到缓存区\ngit add &lt;文件路径加文件全名&gt;：提交某些文件到缓存区\ngit status: 查看当前分支的状态\ngit diff: 展示文件在不同版本间的差异，不加参数时，会显示工作区和暂存区的文件差异。\ngit diff [–staged | –cached]: 显示添加到暂存区但是还未提交的修改内容。\ngit pull &lt;远程仓库名&gt; &lt;远程分支名&gt;: [&lt;本地分支名&gt;]: 拉取远程仓库的分支与本地当前分支合并[与传入参数的分支合并]。\ngit commit -m “&lt;注释&gt;”: 提交代码到本地仓库，并写上提交注释。（必须写注释否则提交失败）\ngit commit -v: 提交时显示所有diff信息\ngit rm –cached &lt;文件名&gt;:  删除缓存区文件 加上 -r 参数可以递归删除\n\n4. 分支操作\ngit branch: 查看本地所有分支\ngit branch -r: 查看远程所有分支\ngit branch -a: 查看本地和远程所有分支\ngit merge &lt;分支名&gt;: 合并分支\ngit merge –abort: 合并分支出现冲突时，取消合并，一切回到合并前的状态\ngit branch &lt;新分支名&gt;: 基于当前分支，新建一个分支\ngit checkout –orphan&lt;新分支名&gt;: 新建一个空分支(会保留之前分支的所有文件)\ngit branch-D&lt;分支名&gt;: 删除本地某个分支\ngit push&lt;远程库名&gt;:&lt;分支名&gt;: 删除远程某个分支\ngit branch &lt;新分支名称&gt; &lt;提交ID&gt;: 从提交历史恢复某个删掉的某个分支\ngit branch -m &lt;原分支名&gt;&lt;新分支名&gt;: 分支更名\ngit checkout &lt;分支名&gt;: 切换到本地某个分支\ngit checkout &lt;远程库名&gt;&#x2F;&lt;分支名&gt;: 切换到线上某个分支\ngit checkout -b &lt;新分支名&gt;: 把基于当前分支新建分支，并切换为这个分支\n\n5. 远程同步\ngit fetch［remote］: 下载远程仓库的所有变动\ngit remote-v: 显示所有远程仓库\ngit pull [remote] [branch]: 拉取远程仓库的分支与本地当前分支合并\ngit fetch: 获取线上最新版信息记录，不合并\ngit push [remote] [branch]: 上传本地指定分支到远程仓库\ngit push [remote］–force: 强行推送当前分支到远程仓库，即使有冲突\ngit push［remote］–all: 推送所有分支到远程仓库\n\n","categories":["工具"],"tags":["工具"]},{"title":"git 工作流程介绍","url":"/2025/10/04/%E5%B7%A5%E5%85%B7-git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D/","content":"git介绍git 是什么？  git是一个先进的分布式版本控制系统。版本控制可以在编写代码时为你的文件生成快照，而这些快照保存的就是当时你文件的状态，如果发生了一些误删操作，就可以通过这个快照回溯到当时的那个状态。\nGit的工作流程图  \n","categories":["工具"],"tags":["工具"]},{"title":"vim","url":"/2025/10/01/%E5%B7%A5%E5%85%B7-vim/","content":"vim介绍vim 是一个强大的文本编辑器，是 vi 的增强版，广泛用于 Linux 和UNIX 系统中，因为它不仅仅有文本编辑功能还可以进行复杂的文本操作。\n模式和切换vim 有三种主要模式：\n普通模式（Normal Mode）：你可以在这个模式下进行光标移动、删除、复制、粘贴等操作。\n插入模式（Insert Mode）：在这个模式下，你可以像普通文本编辑器一样输入内容。\n命令模式（Command Mode）：你可以在这个模式下输入命令来保存文件、退出等。\n\n模式切换：\n从 普通模式 切换到 插入模式：按 i（插入光标前）、I（行首插入）、a（光标后插入）、A（行尾插入）等。\n从 插入模式 切换回 普通模式：按 Esc 键。\n从 普通模式 切换到 命令模式：按 : 键。\n\nvim 启动# 打开文件：vim filename# 打开指定文件vim example.txt# 直接使用vim# 启动并打开一个空文件\nvim 中编辑\n进入插入模式\n\n在普通模式下，按下 i 进入插入模式。此时可以输入文本。\n常见的插入模式快捷键：\n\ni：光标前插入\nI：行首插入\na：光标后插入\nA：行尾插入\no：在当前行下方新建一行并插入\nO：在当前行上方新建一行并插入\n\n\n返回到普通模式\n\n在插入模式下，按 Esc 键返回到普通模式。\n常用操作\n移动光标  在普通模式下，光标移动是 Vim 的核心功能之一。你可以用以下键来精确控制光标：\nh：向左移动一个字符\nj：向下移动一行\nk：向上移动一行\nl：向右移动一个字符 更快速的移动：\nw：移动到下一个单词的开头\nb：移动到当前单词的开头\ne：移动到当前单词的结尾\n0：移动到当前行的行首\n$：移动到当前行的行尾\ngg：移动到文件的开头\nG：移动到文件的结尾\n\n\n复制、剪切和粘贴\nyy：复制当前行\n2yy：复制当前行及其下方的 1 行（2 行）\ndd：删除当前行\n2dd：删除当前行及其下方的 1 行（2 行）\np：在光标后粘贴（在行内粘贴）\nP：在光标前粘贴（在行首粘贴）\n\n\n保存和退出 # 保存文件:w# 退出 vim:q# 保存并退出:wq# 强制退出不保存:q!\n搜索和替换# 向前搜索：/ 然后输入搜索的关键字 按回车/keyword# n 查找下一个匹配项 N 查找上一个匹配项# 向后搜索：? 然后输入搜索关键字 按回车?keyword# 替换文件中的一个单词:%s/old/new/g# 将 old 全部替换为 new# %:表示整个文件# g:表示替换行中所有项（不加 g 只替换每行第一个匹配项）# 仅替换当前行：:s/old/new/g# 替换并确认每个替换：:%s/old/new/gc\n其他命令\n\n\n撤销操作：\nu：撤销上一个操作。\nCtrl + r：恢复撤销的操作。\n\n\n重做操作：\nCtrl + r：重做操作。\n\n\n查看文件信息：\n:set number：显示行号。\n:set nonumber：隐藏行号。\n\n\n跳转到特定行：\n:123：跳转到第 123 行。\n\n\n\n","categories":["工具"],"tags":["工具","linux"]},{"title":"markdown语法","url":"/2025/08/20/%E7%8E%AF%E5%A2%83&%E9%85%8D%E7%BD%AE-markdown%20%E8%AF%AD%E6%B3%95/","content":"markdown语法标题语法根据# 号个数,每个# 号都代表一级标题.根据自己的层次结构决定使用几个#号。一般是有递进规律，一个井号的只用一次。\n换行语法在一行的末尾添加两个或者多个空格，\n然后回车可创建一个空行。\n强调语法粗体：请在单词或短语的前后各添加两个星号或下划线。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号。\n斜体：与粗体类似，可使用一个星号将想要斜体效果的部分引上。\n注意！！！： 可以使用三星号将想要特殊效果的部分引起来，代表斜体和粗体都加上了。\n引用语法\n用大于号代表引用,块引用就是将所有的行前都加上大于号\n\n嵌套引用也是支持的\n\n\n列表语法有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n\n\n\n\n\n无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n\n\n\n\n\n代码语法反引号： printf(&quot;hello world&quot;); 行代码\n围栏式代码块： 用三个反引号跟上代码语言，最后由三个反引号收尾。\npublic class Main &#123;    public static void main(String[] args) &#123;    System.out.println(&quot;hello world &quot;);    &#125;&#125;\n\n分割线语法\n要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。\n\n链接语法中括号加小括号语法 中括号内写名称（随便写） 小括号内写地址\n百度\n图片语法与链接语法类似但是要注意前面有个叹号。\n![图片](图片地址)\n表格语法用竖杠代表表格分割  |\n\n&gt;| 表头     | 表头 |&gt;|: -----------  :|: ----------- :| //在此可进行格式控制，加上：代表向左对齐或者向右对齐，都加时居中对齐, - 的数量与表格布局无关&gt;| Paragraph   | Text        |\n\n\n\n\n姓名\n班级\n年龄\n\n\n\n张三\n计科233\n18\n\n\n !!!注意 \n\n\n列表标题语法和需要在符号后加空格才会生效。\n所有格式控制符号一定是英文符号。\n有些找不到的键符可以在功能键下边那一行找，例如反引号在左上角。\n可以使用markdown编译器。 本地的 typora 或者是多端共享数据放在厂商服务器上的 语雀 ；自由选择编译器。可以在编译器上写好之后往博客上粘贴。\n我这里只是列举了简单的语法的基本使用，其他语法可以自行了解。\nmarkdown官网\n在word或者编译器中直接跳转链接需要使用ctrl键和鼠标点击。\n\n","categories":["学习笔记"],"tags":["学习笔记"]},{"title":"打包apk文件","url":"/2025/08/26/%E7%8E%AF%E5%A2%83&%E9%85%8D%E7%BD%AE-%E6%89%93%E5%8C%85apk%E6%96%87%E4%BB%B6/","content":"将 uniapp 项目打包成 安卓手机应用 apk环境准备打包安卓应用，首先需要的编辑器有 Android Studio，hbuilderx.hbuilderx是对 uniapp 应用具有极好的适配。\n云打包通过使用DCloud账号登录后，可以通过 hbx 直接云端打包，打包完成后可以根据提示路径下载apk文件。本文的重点是介绍，本地打包。\n本地打包\n使用 hbuilderx 打开项目，并选择 发行 -&gt; 本地打包 -&gt; 生成本地打包资源 。这一步通常是生成了一个 UNI*** 的文件夹。这个文件夹里就是本地的打包资源。\n打开 Android Studio ，新建项目，选择导入项目，选择 android&#x2F;app 文件夹。\n将证书文件复制到 android&#x2F;app 文件夹下。 android 证书通常是 .keystore 或者 .jks 文件。\n在这个目录下 找到 build.gradle 文件，配置证书路径密码。\n将android 文件夹导入到 android studio 中。\n点左侧的菜单栏选择 Build-&gt; Generate App Bundles or APKs  -&gt; Generate APKs\n\nothers！配置 appid 在 android&#x2F;app&#x2F;assets&#x2F;data&#x2F;dcloud_control.xml  文件中 UNI*** 格式的appid 配置。\n！需要在dcloud 账号中申请appid,注册并且完成认证，和创建项目。才能完成云打包。\n！获取安卓证书：获取安卓证书\n","categories":["环境&配置"],"tags":["环境&配置"]},{"title":"http 状态码","url":"/2025/12/10/%E8%AE%A1%E7%BD%91-http%E7%8A%B6%E6%80%81%E7%A0%81/","content":"http 状态码概述这些状态码只是协议规定，大部分状态码都是开发者根据业务逻辑自定义的。一般情况下，接口一般都是直接全部做 200 处理，然后在响应体中定义 code 或者其他字段来表示业务状态码。进行深度的业务处理。\n状态码分类这些都是响应状态码，用于描述 HTTP 请求的处理结果。\n一、1xx 信息性状态码（请求已接收，需要客户端继续处理）表示服务器已收到请求，需客户端继续操作或等待进一步处理。这类状态码在实际应用中较少见。\n\n100 Continue：服务器已收到请求的初始部分，客户端可继续发送剩余请求体。\n101 Switching Protocols：服务器同意切换协议（如从 HTTP 切换到 WebSocket）。\n103 Early Hints：服务器提前返回资源提示，用于优化页面加载（HTTP&#x2F;2 新特性）。\n\n二、2xx 成功状态码（请求已成功处理）表示客户端请求已被服务器成功接收、理解并处理。\n\n200 OK 请求成功，返回预期资源常规 API 请求成功响应\n201 Created 请求已创建新资源（如 POST 请求）新增用户、创建订单后\n202 Accepted 请求已接受但尚未处理完成（异步操作）|提交批量任务后\n204 No Content 请求成功但无返回内容 删除资源后，无需返回数据\n206 Partial Content 成功返回部分资源（用于分片请求）大文件断点续传\n\n三、3xx 重定向状态码（需客户端进一步操作以完成请求）表示资源位置发生变化，需客户端重定向到新 URL。一般常见 301 和 302 。\n\n301 Moved Permanently：资源永久重定向（SEO 需注意更新链接）。  例：网站域名变更（旧域名→新域名）。\n302 Found：资源临时重定向（默认重定向方式）。  例：未登录用户访问需要权限的页面，重定向到登录页。\n303 See Other：请求的响应需重定向到其他 URL（常用于 POST 请求后的重定向）。  例：表单提交成功后跳转到结果页。\n304 Not Modified：资源未修改，可使用缓存（客户端需验证缓存有效性）。  例：浏览器请求已缓存的静态资源，服务器确认无需更新。\n307 Temporary Redirect：临时重定向（保留原始请求方法）。  例：HTTPS 强制跳转（HTTP→HTTPS）。\n308 Permanent Redirect：永久重定向（保留原始请求方法）。  例：API 版本升级后，旧接口永久指向新接口。\n\n四、4xx 客户端错误状态码（客户端请求存在错误）表示客户端请求有误，服务器无法处理。对于前端来说，最应该注意的状态码。\n\n400 Bad Request 请求格式错误或参数无效 发送 JSON 格式错误、缺少必填参数\n401 Unauthorized 未授权（需身份验证）登录 token 过期、未提供认证信息\n403 Forbidden 禁止访问（无权限）用户权限不足、IP 被封禁\n404 Not Found 资源不存在 访问 URL 错误、资源被删除\n405 Method Not Allowed 请求方法不允许，对仅支持 GET 的接口发送 POST 请求\n408 Request Timeout 请求超时，服务器未在规定时间内收到请求\n429 Too Many Requests 请求频率过高（限流） 短时间内多次请求触发频率限制\n415 Unsupported Media Type 不支持的媒体类型 发送服务器无法解析的格式（如请求体为 text&#x2F;plain 但服务器要求 JSON）\n\n五、5xx 服务器错误状态码（服务器处理请求时发生错误）表示服务器在处理请求时内部出错，无法完成请求。常见于后端错误。\n\n500 Internal Server Error：服务器内部错误（最常见的服务器端异常）。  例：代码执行报错、数据库连接失败。\n501 Not Implemented：服务器不支持请求的功能。  例：请求服务器未实现的 HTTP 方法或 API 接口。\n502 Bad Gateway：网关错误（代理服务器获取不到上游服务器的响应）。  例：Nginx 代理后端服务时，后端服务崩溃。\n503 Service Unavailable：服务不可用（服务器暂时无法处理请求）。  例：服务器过载、正在维护（常伴随 Retry-After 响应头）。\n504 Gateway Timeout：网关超时（代理服务器等待上游服务器响应超时）。  例：后端服务处理缓慢，代理服务器等待超时而返回错误。\n511 Network Authentication Required：需要网络认证（客户端未完成网络层认证）。  例：公共 WiFi 的认证页面跳转前返回此状态码。\n\n","categories":["计算机网络"],"tags":["计算机网络"]},{"title":"应用层协议","url":"/2025/12/06/%E8%AE%A1%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/","content":"应用层协议概念介绍URI 统一资源标识符 : URI（统一资源标识符）&#x3D; URL（统一资源定位符） + URN（统一资源名称）\nURL 统一资源定位符 : 统一资源定位符（URL）是互联网上用于唯一标识资源的字符串，它包含协议、域名、端口号、路径、文件名、参数等信息。是使用最广泛的统一资源标识符。\nURN 统一资源名称 : 通过 “永久、唯一的名称” 标识资源，与资源的 “位置无关”—— 即使资源的存储位置发生变化，URN 依然有效。用的很少。\nURLURL 本质就是一个固定格式的字符串： 协议(scheme)://域名(domain):端口号(port)/路径(path)?参数(query)#锚点(hash)这个字符串就规定终端该从互联网世界的哪个位置获取数据。\n\n\nhttp 默认端口是 80 https 默认端口是 443 使用默认端口时可省略端口。\nscheme path domain 都是必填的。scheme 是会默认被补齐的，path也会，如果没有就会补上 &#x2F;。 这就是为什么直觉上这些都认为是可以省略的。\n\n\nhttp 协议http 是一种纯文本的传输协议，基于 TCP 协议。他是双向共同遵守一个标准的通信协议。http 通过 request 请求和 response 响应来完成数据传输。这个文本分为三部分：\n\n请求行：请求方式（get）+ 请求的资源路径(path + query) 请求的协议版本(HTTP&#x2F;1.1)\n请求头：请求头信息 (key:value) 例如 Content-Type: application/json(请求体的个数) –&gt; mime 类型，告诉服务器我请求的数据是什么格式的。广泛用在网络传输中。\n请求体：请求数据(不能为空，可以留白)\n\n对应于响应：\n\n响应行：响应的协议版本 响应状态码 响应状态码描述\n响应头：响应头信息\n响应体：响应数据\n\nhttp 状态码\n","categories":["计算机网络"],"tags":["计算机网络"]},{"title":"计算机网络概述","url":"/2025/11/30/%E8%AE%A1%E7%BD%91-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/","content":"计算机网络概述介绍计算机网络是通过通信线路连接起来的、能够进行数据传输和资源共享的计算机系统的集合。它使得不同地理位置的计算机之间可以互相通信、共享资源和协同工作。最初是源于1959年美国麻省理工学院（MIT）的计算机网络基础研究小组，由 John von Neumann 创建。\n概念： 利用通信线路和交换设备将地理位置分散的、具有独立功能的计算机连接起来，按照某种协议进行数据通信、实现资源共享的信息系统。\n分类按覆盖范围分类：\n\n局域网（LAN）：覆盖范围小，通常在一个建筑物或校园内\n城域网（MAN）：覆盖范围中等，通常在一个城市内\n广域网（WAN）：覆盖范围大，通常跨越多个城市、国家或洲际\n个人区域网（PAN）：覆盖范围非常小，通常在个人设备之间\n\n按传输协议分类：\n\n以太网（Ethernet）：最常用的局域网技术\n无线局域网（WLAN）：使用无线技术进行数据传输\n光纤分布式数据接口（FDDI）：使用光纤进行高速数据传输\n异步传输模式（ATM）：用于广域网的高速数据传输\n互联网协议套件（TCP&#x2F;IP）：用于全球互联网的数据传输\n\n按拓扑结构分类：\n\n总线型拓扑：所有设备连接到一条共享的通信线路上\n星型拓扑：所有设备都连接在一个中心节点上，其他设备通过中心节点进行通信\n环型拓扑：设备连接成一个闭合的环，数据沿环路传输\n网状型形拓扑：设备之间通过一个中心节点进行通信，每个设备都连接在网络中的某个节点上jk\n\n分层模型关于分层结构：\ntcp&#x2F;ip 五层模型（最新的模型）\n\n应用层 –&gt; 具体应用格式中的消息（数据）格式 –&gt; http、ftp、dns、smtp等\n传输层 –&gt; 在网络中如何传输消息 –&gt; tcp &#x2F; udp（不可靠，会丢包）\n网络层 –&gt; 在网络中如何定位 –&gt; ip 地址、路由器\n数据链路层 –&gt; 在子网中如何定位 –&gt; mac 地址 、交换机\n物理层 –&gt; 用什么信号表示上边这些层数据,通过什么东西传输信号 –&gt; 光纤、双绞线、集线器等硬件。\n\ntcp&#x2F;ip 四层模型（最先的模型）\n\n应用层 –&gt; 具体应用格式中的消息（数据）格式 –&gt; http、ftp、dns、smtp等\n传输层 –&gt; 在网络中如何传输消息 –&gt; tcp &#x2F; udp（不可靠，会丢包）\n网络层 –&gt; 在网络中如何定位 –&gt; ip 地址、路由器\n物理链路层 –&gt; 在子网中如何定位 –&gt; mac 地址 、交换机 ，合并了数据链路层和物理层\n\nosi 七层网络模型（用的不多）\n\n7应用层 –&gt; 提供用户接口，支持网络应用（如 HTTP、FTP、SMTP、DNS 等）\n6表示层 –&gt; 数据格式转换、加密解密、压缩解压等（如 JPEG、MPEG、SSL&#x2F;TLS）\n5会话层 –&gt; 建立、管理和终止会话（如远程登录、同步控制）\n4传输层 –&gt; 端到端通信、可靠&#x2F;不可靠数据传输、流量控制、错误恢复（如 TCP、UDP）\n3网络层 –&gt; 路由选择、逻辑寻址（IP 地址）、分组转发（如 IP、ICMP、ARP）\n2数据链路层 –&gt; 物理地址（MAC）、帧封装、差错检测、介质访问控制（如 Ethernet、PPP、Wi-Fi）\n1物理层 –&gt; 在物理媒介上传输原始比特流（如电缆、光纤、无线信号；定义电压、速率等）–&gt; 在物理媒介上实现比特流的透明传输。\n\n层次结构的设计原则\n各层之间相互独立。\n每一层足够灵活。\n各层之间完全解耦。\n\n","categories":["计算机网络"],"tags":["计算机网络"]},{"title":"nginx > location 指令","url":"/2025/09/27/%E8%BF%90%E7%BB%B4-nginx-location%E6%8C%87%E4%BB%A4/","content":"location 指令语法location [匹配模式] URI模式 {    # 匹配成功后执行的配置（如反向代理、静态文件映射等）    配置项;}\n顺序即为优先级 &gt;&gt;&gt;&gt;\n\n\n\n匹配模式符号\n模式名称\n匹配规则\n\n\n\n=\n精确匹配\n仅匹配 URI 完全等于 URI模式 的请求，优先级最高\n\n\n^~\n前缀匹配（优先）\n匹配以 URI模式 开头的请求，不进行正则匹配，优先级次之\n\n\n~ &#x2F; ~*\n正则匹配\n~ 区分大小写优先级高于不区分大小写，~* 不区分大小写，匹配符合正则表达式的 URI\n\n\n无符号\n前缀匹配（普通）\n匹配以 URI模式 开头的请求，优先级低于 ^~，若有正则匹配则优先正则\n\n\nserver &#123;    listen 80;    server_name example.com;    # 1. 精确匹配：仅匹配 / （根路径）    location = / &#123;        return 200 &quot;精确匹配根路径&quot;;    &#125;    # 2. 前缀优先匹配：匹配以 /static/ 开头的请求（如 /static/css/main.css）    location ^~ /static/ &#123;        root /usr/share/nginx/html; # 静态文件根目录    &#125;    # 3. 正则匹配：匹配以 .html 结尾的请求（区分大小写）    location ~ \\.html$ &#123;        return 200 &quot;正则匹配 HTML 文件&quot;;    &#125;    # 4. 普通前缀匹配：匹配以 /api 开头的请求（如 /api/user、/api/order）    location /api &#123;        proxy_pass http://127.0.0.1:3000; # 反向代理到后端服务    &#125;    # 5. 普通前缀匹配：最长匹配兜底（所有未匹配的请求）    location / &#123;        return 404 &quot;未找到匹配的路径&quot;;    &#125;&#125;\n","categories":["运维"],"tags":["nginx"]},{"title":"nginx","url":"/2025/09/24/%E8%BF%90%E7%BB%B4-nginx/","content":"nginx介绍nginx（发音同“engine x”）是一个高性能的 HTTP 和反向代理服务器，同时也支持邮件代理。它主要是为了解决高并发问题而出现的。\n安装方式主流的安装方式有三种：\n\n源码安装\n对应的软件包安装\nDocker 镜像安装\n\n在服务器环境上，docker安装确实最为推荐。不管是nginx还是其他的服务器，docker安装方式都相对简单，而且安装后，配置文件也相对简单。而且不用了直接删除容器。\nnginx 命令nginx -s reload  # 向主进程发送信号，重新加载配置文件，热重启nginx -s reopen  # 重启 Nginxnginx -s stop    # 快速关闭nginx -s quit    # 等待工作进程处理完成后关闭nginx -T         # 查看当前 Nginx 最终的配置，会在终端中打印出来nginx -t -c &lt;配置路径&gt;    # 检查配置文件的语法，默认路径不需要 -c 参数\nsystemctl start nginx    # 启动 Nginxsystemctl stop nginx     # 停止 Nginxsystemctl restart nginx  # 重启 Nginxsystemctl reload nginx   # 重新加载 Nginx，用于修改配置后systemctl enable nginx   # 设置开机启动 Nginxsystemctl disable nginx  # 关闭开机启动 Nginxsystemctl status nginx   # 查看 Nginx 运行状态\nnginx 配置文件文件位置：&#x2F;etc&#x2F;nginx&#x2F;nginx.conf 源码编译的：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf文件结构：    main # 全局配置，对全局生效    ├── events  # 配置影响 Nginx 服务器或与用户的网络连接    ├── http    # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置    │   ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分    │   ├── server   # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块    │   ├── server    │   │   ├── location  # server 块可以包含多个 location 块，location 指令用于匹配 uri    │   │   ├── location    │   │   └── …    │   └── …└── …\n反向代理、负载均衡反向代理：将用户请求转发给后端服务器，并返回结果给用户。对反向代理的理解首先要理解正向代理，正向代理在客户端一侧配置，客户端 → 正向代理 → 目标服务器，也就是正常的访问流程。反向代理是在服务端一侧配置，目标服务器 → 反向代理服务器 → 服务器集群。对客户端来说，反向代理是无感的。也就是说对服务端的代理（也可以说是对客户端来的请求进行了转发）这就是反向代理。\nserver &#123;  listen 9001;  server_name *.sherlocked93.club;  location ~ /edu/ &#123;    proxy_pass http://127.0.0.1:8080;  &#125;  location ~ /vod/ &#123;    proxy_pass http://127.0.0.1:8081;  &#125;&#125;\n\n负载均衡：将用户请求平均分配给多个后端服务器，从而提高服务器的负载。负载均衡的原理是把用户请求平均分配给多个后端服务器，从而提高服务器的负载。负载均衡的原理是把用户请求平均分配给多个后端服务器，从而提高服务器的负载。也是可以设置权重的为更高性能的服务器分配更多请求。\nhttp &#123;  upstream myserver &#123;    # ip_hash;  # ip_hash 方式    # fair;   # fair 方式    server 127.0.0.1:8081;  # 负载均衡目的服务地址    server 127.0.0.1:8080;    server 127.0.0.1:8082 weight=10;  # weight 方式，不写默认为 1 设置权重  &#125;  server &#123;    location / &#123;      proxy_pass http://myserver;      proxy_connect_timeout 10;    &#125;  &#125;&#125;\n\n","categories":["运维"],"tags":["nginx"]},{"title":"随笔24/8/2","url":"/2024/07/28/%E9%9A%8F%E7%AC%9424_8_2/","content":"font 字体属性的简写时font:italic 700 24px/56px arial, sans-serif;第一个font-style 第二个font-weight 第三个font-size/line-height最后是font-family的列表优先级是先后顺序。注意：font-size &amp; font-family不可省略，否则不会生效。\n禁用按钮cursor:not-allowed;红色禁用标记backgroung-clip:text;当背景为渐变色时，文字会有较好的渐变效果。\n动态传值以及页面动态效果开发的最终方案关于动态传值问题传值问题可以从表单元素的value属性说起，在这个属性中可以储存从后台拿到的值，但是普通的div等页面的元素可以使用自定义数据类型进行动态传值 data-value data-id等 ，要注意这些属性保存的都是字符串，取出时应该用.getAttribute(&#39;data-value&#39;)拿到\n页面动态效果开发如果只是用 js 控制style改变的均为内联样式，这种方式在微调方面效果显著，但是这种方式调节的是元素的内联样式，在需要大型的调整或者动大的变化时这种方式并不适用，应该通过调整元素的类名改变。、\n控制元素类名的方式\n通过 className，每个元素的 className 都是，它的类名，改变时可以直接赋值上新的类名，原来的类名将会被覆盖掉，所以常有这样的操作,来追加类名，但是不能将加号换成减号直接使用。element.className+=&quot;NewClassName&quot; 2.通过 classList,使用 className 调整类名时还是比较麻烦，所以直接用 classList。(1)通过 ClassList 可以获取元素的全部类名;(2)通过 ClassList.remove()可以删除元素的一个或多个类名；(3)通过 ClassList.add()可以向元素添加一个或多个类名;(4)通过 ClassList.lentgh 可以获取到元素类名的数目；(5)通过 ClassList.item(x)可以获取到元素类名索引为 x 的类名;(6)通过 ClassList.toggle()可以为元素切换类，只能有一个类名;(7)通过 ClassList.contains(x)查看元素是否存在类名为”x”的类;！！！添加删除多个类名时记得是用逗号隔开的参数，不能用空格隔开的类名列表。\n\ntextarea 文本域不加处理时用户可以自由拉伸可以加上`resize : none;`取消这个事件。与他自己的闭合标签中不能有任何东西，包括空格。\n\n事件监听设置事件细分有三种方式\n1. 在script标签中\n`&lt;div class=&quot;small&quot; onclick=&quot;(function()&#123;console.log(&#39;第一次点击&#39;)&#125;)()&quot;&gt;domNode&lt;/div&gt;`\n2.快捷绑定\n`&lt;script&gt;domNode.onclick=function()&#123;console.log(&#39;script&#39;)&#125;&lt;/script&gt;`\n3.监听\n``` js\n\ndomNode.addEventListener(‘click’,function(){        console.log(‘第一次点击’)    })    domNode.addEventListener(‘click’,function(){        console.log(‘第二次点击’)    })&#96;&#96;&#96;！！！先后顺序与排序相同，第三种可以绑定多个，前面的会造成覆盖。\n","categories":["随笔"]}]